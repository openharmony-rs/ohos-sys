/* automatically generated by rust-bindgen 0.70.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
pub struct OH_Drawing_Canvas {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Pen {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Region {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Brush {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Path {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Bitmap {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Point {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_PixelMap {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_ColorSpace {
    _unused: [u8; 0],
}
/** @brief Defines a point of 2d.

@since 12
@version 1.0*/
#[repr(C)]
pub struct OH_Drawing_Point2D {
    pub x: f32,
    pub y: f32,
}
/** @brief Defines a corner radii, which is on x-axis and y-axis.

@since 12
@version 1.0*/
pub type OH_Drawing_Corner_Radii = OH_Drawing_Point2D;
/** @brief Defines a point of 3d, which is used to describe the coordinate point.

@since 12
@version 1.0*/
#[repr(C)]
pub struct OH_Drawing_Point3D {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
pub struct OH_Drawing_PathEffect {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Rect {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_RoundRect {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Matrix {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_ShaderEffect {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_ShadowLayer {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Filter {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_MaskFilter {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_ColorFilter {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Font {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_MemoryStream {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Typeface {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_TextBlob {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Image {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_ImageFilter {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_SamplingOptions {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_TextBlobBuilder {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_GpuContext {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_Surface {
    _unused: [u8; 0],
}
impl OH_Drawing_ColorFormat {
    /// Unknown format.
    pub const COLOR_FORMAT_UNKNOWN: OH_Drawing_ColorFormat = OH_Drawing_ColorFormat(0);
}
impl OH_Drawing_ColorFormat {
    /// Each pixel is represented by 8 bits, which together indicate alpha.
    pub const COLOR_FORMAT_ALPHA_8: OH_Drawing_ColorFormat = OH_Drawing_ColorFormat(1);
}
impl OH_Drawing_ColorFormat {
    /** Each pixel is represented by 16 bits. From the most significant bit to the least significant bit,
    the first 5 bits indicate red, the subsequent 6 bits indicate green, and the last 5 bits indicate blue.*/
    pub const COLOR_FORMAT_RGB_565: OH_Drawing_ColorFormat = OH_Drawing_ColorFormat(2);
}
impl OH_Drawing_ColorFormat {
    /** Each pixel is represented by 16 bits. From the most significant bit to the least significant bit,
    every 4 bits indicate alpha, red, green, and blue, respectively.*/
    pub const COLOR_FORMAT_ARGB_4444: OH_Drawing_ColorFormat = OH_Drawing_ColorFormat(3);
}
impl OH_Drawing_ColorFormat {
    /** Each pixel is represented by 32 bits. From the most significant bit to the least significant bit,
    every 8 bits indicate alpha, red, green, and blue, respectively.*/
    pub const COLOR_FORMAT_RGBA_8888: OH_Drawing_ColorFormat = OH_Drawing_ColorFormat(4);
}
impl OH_Drawing_ColorFormat {
    /** Each pixel is represented by 32 bits. From the most significant bit to the least significant bit,
    every 8 bits indicate blue, green, red, and alpha, respectively.*/
    pub const COLOR_FORMAT_BGRA_8888: OH_Drawing_ColorFormat = OH_Drawing_ColorFormat(5);
}
#[repr(transparent)]
/** @brief Enumerates storage formats of bitmap pixels.

@since 8
@version 1.0*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_Drawing_ColorFormat(pub ::core::ffi::c_uint);
impl OH_Drawing_AlphaFormat {
    /// Unknown format.
    pub const ALPHA_FORMAT_UNKNOWN: OH_Drawing_AlphaFormat = OH_Drawing_AlphaFormat(0);
}
impl OH_Drawing_AlphaFormat {
    /// The bitmap does not have the alpha component.
    pub const ALPHA_FORMAT_OPAQUE: OH_Drawing_AlphaFormat = OH_Drawing_AlphaFormat(1);
}
impl OH_Drawing_AlphaFormat {
    /// The color component of each pixel is premultiplied by the alpha component.
    pub const ALPHA_FORMAT_PREMUL: OH_Drawing_AlphaFormat = OH_Drawing_AlphaFormat(2);
}
impl OH_Drawing_AlphaFormat {
    /// The color component of each pixel is not premultiplied by the alpha component.
    pub const ALPHA_FORMAT_UNPREMUL: OH_Drawing_AlphaFormat = OH_Drawing_AlphaFormat(3);
}
#[repr(transparent)]
/** @brief Enumerates alpha formats of bitmap pixels.

@since 8
@version 1.0*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_Drawing_AlphaFormat(pub ::core::ffi::c_uint);
impl OH_Drawing_BlendMode {
    /// r = 0.
    pub const BLEND_MODE_CLEAR: OH_Drawing_BlendMode = OH_Drawing_BlendMode(0);
}
impl OH_Drawing_BlendMode {
    /// r = s.
    pub const BLEND_MODE_SRC: OH_Drawing_BlendMode = OH_Drawing_BlendMode(1);
}
impl OH_Drawing_BlendMode {
    /// r = d.
    pub const BLEND_MODE_DST: OH_Drawing_BlendMode = OH_Drawing_BlendMode(2);
}
impl OH_Drawing_BlendMode {
    /// r = s + (1-sa)*d.
    pub const BLEND_MODE_SRC_OVER: OH_Drawing_BlendMode = OH_Drawing_BlendMode(3);
}
impl OH_Drawing_BlendMode {
    /// r = d + (1-da)*s.
    pub const BLEND_MODE_DST_OVER: OH_Drawing_BlendMode = OH_Drawing_BlendMode(4);
}
impl OH_Drawing_BlendMode {
    /// r = s * da.
    pub const BLEND_MODE_SRC_IN: OH_Drawing_BlendMode = OH_Drawing_BlendMode(5);
}
impl OH_Drawing_BlendMode {
    /// r = d * sa.
    pub const BLEND_MODE_DST_IN: OH_Drawing_BlendMode = OH_Drawing_BlendMode(6);
}
impl OH_Drawing_BlendMode {
    /// r = s * (1-da).
    pub const BLEND_MODE_SRC_OUT: OH_Drawing_BlendMode = OH_Drawing_BlendMode(7);
}
impl OH_Drawing_BlendMode {
    /// r = d * (1-sa).
    pub const BLEND_MODE_DST_OUT: OH_Drawing_BlendMode = OH_Drawing_BlendMode(8);
}
impl OH_Drawing_BlendMode {
    /// r = s*da + d*(1-sa).
    pub const BLEND_MODE_SRC_ATOP: OH_Drawing_BlendMode = OH_Drawing_BlendMode(9);
}
impl OH_Drawing_BlendMode {
    /// r = d*sa + s*(1-da).
    pub const BLEND_MODE_DST_ATOP: OH_Drawing_BlendMode = OH_Drawing_BlendMode(10);
}
impl OH_Drawing_BlendMode {
    /// r = s*(1-da) + d*(1-sa).
    pub const BLEND_MODE_XOR: OH_Drawing_BlendMode = OH_Drawing_BlendMode(11);
}
impl OH_Drawing_BlendMode {
    /// r = min(s + d, 1).
    pub const BLEND_MODE_PLUS: OH_Drawing_BlendMode = OH_Drawing_BlendMode(12);
}
impl OH_Drawing_BlendMode {
    /// r = s*d.
    pub const BLEND_MODE_MODULATE: OH_Drawing_BlendMode = OH_Drawing_BlendMode(13);
}
impl OH_Drawing_BlendMode {
    /// r = s + d - s*d.
    pub const BLEND_MODE_SCREEN: OH_Drawing_BlendMode = OH_Drawing_BlendMode(14);
}
impl OH_Drawing_BlendMode {
    /// multiply or screen, depending on destination.
    pub const BLEND_MODE_OVERLAY: OH_Drawing_BlendMode = OH_Drawing_BlendMode(15);
}
impl OH_Drawing_BlendMode {
    /// rc = s + d - max(s*da, d*sa), ra = s + (1-sa)*d.
    pub const BLEND_MODE_DARKEN: OH_Drawing_BlendMode = OH_Drawing_BlendMode(16);
}
impl OH_Drawing_BlendMode {
    /// rc = s + d - min(s*da, d*sa), ra = s + (1-sa)*d.
    pub const BLEND_MODE_LIGHTEN: OH_Drawing_BlendMode = OH_Drawing_BlendMode(17);
}
impl OH_Drawing_BlendMode {
    /// brighten destination to reflect source.
    pub const BLEND_MODE_COLOR_DODGE: OH_Drawing_BlendMode = OH_Drawing_BlendMode(18);
}
impl OH_Drawing_BlendMode {
    /// darken destination to reflect source.
    pub const BLEND_MODE_COLOR_BURN: OH_Drawing_BlendMode = OH_Drawing_BlendMode(19);
}
impl OH_Drawing_BlendMode {
    /// multiply or screen, depending on source.
    pub const BLEND_MODE_HARD_LIGHT: OH_Drawing_BlendMode = OH_Drawing_BlendMode(20);
}
impl OH_Drawing_BlendMode {
    /// lighten or darken, depending on source.
    pub const BLEND_MODE_SOFT_LIGHT: OH_Drawing_BlendMode = OH_Drawing_BlendMode(21);
}
impl OH_Drawing_BlendMode {
    /// rc = s + d - 2*(min(s*da, d*sa)), ra = s + (1-sa)*d.
    pub const BLEND_MODE_DIFFERENCE: OH_Drawing_BlendMode = OH_Drawing_BlendMode(22);
}
impl OH_Drawing_BlendMode {
    /// rc = s + d - two(s*d), ra = s + (1-sa)*d.
    pub const BLEND_MODE_EXCLUSION: OH_Drawing_BlendMode = OH_Drawing_BlendMode(23);
}
impl OH_Drawing_BlendMode {
    /// r = s*(1-da) + d*(1-sa) + s*d.
    pub const BLEND_MODE_MULTIPLY: OH_Drawing_BlendMode = OH_Drawing_BlendMode(24);
}
impl OH_Drawing_BlendMode {
    /// hue of source with saturation and luminosity of destination.
    pub const BLEND_MODE_HUE: OH_Drawing_BlendMode = OH_Drawing_BlendMode(25);
}
impl OH_Drawing_BlendMode {
    /// saturation of source with hue and luminosity of destination.
    pub const BLEND_MODE_SATURATION: OH_Drawing_BlendMode = OH_Drawing_BlendMode(26);
}
impl OH_Drawing_BlendMode {
    /// hue and saturation of source with luminosity of destination.
    pub const BLEND_MODE_COLOR: OH_Drawing_BlendMode = OH_Drawing_BlendMode(27);
}
impl OH_Drawing_BlendMode {
    /// luminosity of source with hue and saturation of destination.
    pub const BLEND_MODE_LUMINOSITY: OH_Drawing_BlendMode = OH_Drawing_BlendMode(28);
}
#[repr(transparent)]
/** @brief The blending operation generates a new color for the two colors (source, destination).
These operations are the same on the 4 color channels: red, green, blue, alpha.
For these, we use alpha channel as an example, rather than naming each channel individually.

For brevity, we use the following abbreviations.
s  : source
d  : destination
sa : source alpha
da : destination alpha

Results are abbreviated
r  : if all 4 channels are computed in the same manner
ra : result alpha channel
rc : result "color": red, green, blue channels

@since 11
@version 1.0*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_Drawing_BlendMode(pub ::core::ffi::c_uint);
/** @brief Defines image info struct.

@since 12
@version 1.0*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_Image_Info {
    /// storage for width of image
    pub width: i32,
    /// storage for height of image
    pub height: i32,
    /// storage for color formats
    pub colorType: OH_Drawing_ColorFormat,
    /// storage for alpha formats
    pub alphaType: OH_Drawing_AlphaFormat,
}
/** @brief Defines rectstyle info struct.

@since 12
@version 1.0*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_Drawing_RectStyle_Info {
    /// color of rectstyle
    pub color: u32,
    /// radius in left top of rectstyle
    pub leftTopRadius: f64,
    /// radius in right top of rectstyle
    pub rightTopRadius: f64,
    /// radius in right bottom of rectstyle
    pub rightBottomRadius: f64,
    /// radius in left bottom of rectstyle
    pub leftBottomRadius: f64,
}
impl OH_Drawing_TextEncoding {
    /// uses bytes to represent UTF-8 or ASCII
    pub const TEXT_ENCODING_UTF8: OH_Drawing_TextEncoding = OH_Drawing_TextEncoding(0);
}
impl OH_Drawing_TextEncoding {
    /// uses two byte words to represent most of Unicode
    pub const TEXT_ENCODING_UTF16: OH_Drawing_TextEncoding = OH_Drawing_TextEncoding(1);
}
impl OH_Drawing_TextEncoding {
    /// uses four byte words to represent all of Unicode
    pub const TEXT_ENCODING_UTF32: OH_Drawing_TextEncoding = OH_Drawing_TextEncoding(2);
}
impl OH_Drawing_TextEncoding {
    /// uses two byte words to represent glyph indices
    pub const TEXT_ENCODING_GLYPH_ID: OH_Drawing_TextEncoding = OH_Drawing_TextEncoding(3);
}
#[repr(transparent)]
/** @brief Enumerates text encoding types.
@since 12
@version 1.0*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_Drawing_TextEncoding(pub ::core::ffi::c_uint);
#[repr(C)]
pub struct OH_Drawing_FontMgr {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct OH_Drawing_FontStyleSet {
    _unused: [u8; 0],
}
