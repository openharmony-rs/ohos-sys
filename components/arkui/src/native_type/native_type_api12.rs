/* automatically generated by rust-bindgen 0.70.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
/** @brief Defines the ArkUI native component object.

@since 12*/
#[repr(C)]
pub struct ArkUI_Node {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_NodeContent {
    _unused: [u8; 0],
}
/** @brief Defines the pointer type of the ArkUI node content

@since 12*/
pub type ArkUI_NodeContentHandle = *mut ArkUI_NodeContent;
/** @brief Defines the custom dialog box controller of ArkUI on the native side.

@since 12*/
#[repr(C)]
pub struct ArkUI_NativeDialog {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_LayoutConstraint {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_DrawContext {
    _unused: [u8; 0],
}
/** @brief Defines the pointer to the ArkUI native component object.

@since 12*/
pub type ArkUI_NodeHandle = *mut ArkUI_Node;
/** @brief Defines the pointer to the custom dialog box controller of ArkUI on the native side.

@since 12*/
pub type ArkUI_NativeDialogHandle = *mut ArkUI_NativeDialog;
#[repr(C)]
pub struct ArkUI_WaterFlowSectionOption {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_ListItemSwipeActionItem {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_ListItemSwipeActionOption {
    _unused: [u8; 0],
}
/** @brief Defines the ArkUI native context object.

@since 12*/
#[repr(C)]
pub struct ArkUI_Context {
    _unused: [u8; 0],
}
/** @brief Defines the pointer to the context instance object pointer definition of ArkUI on the native side.

@since 12*/
pub type ArkUI_ContextHandle = *mut ArkUI_Context;
#[repr(C)]
pub struct ArkUI_SwiperIndicator {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_AlignmentRuleOption {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_GuidelineOption {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_BarrierOption {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_ListChildrenMainSize {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_ImageAnimatorFrameInfo {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_AccessibilityState {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_AccessibilityValue {
    _unused: [u8; 0],
}
/** @brief Defines the event callback type.

@since 12*/
#[repr(C)]
pub struct ArkUI_ContextCallback {
    /// Custom type.
    pub userData: *mut ::core::ffi::c_void,
    /// Event callback.
    pub callback: ::core::option::Option<unsafe extern "C" fn(userData: *mut ::core::ffi::c_void)>,
}
/** @brief Provides the number types of ArkUI in the native code.

@since 12*/
#[repr(C)]
pub struct ArkUI_NumberValue {
    /// Floating-point type.
    pub f32_: __BindgenUnionField<f32>,
    /// Signed integer.
    pub i32_: __BindgenUnionField<i32>,
    /// Unsigned integer.
    pub u32_: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
impl ArkUI_Alignment {
    /// Top start.
    pub const ARKUI_ALIGNMENT_TOP_START: ArkUI_Alignment = ArkUI_Alignment(0);
}
impl ArkUI_Alignment {
    /// Top center.
    pub const ARKUI_ALIGNMENT_TOP: ArkUI_Alignment = ArkUI_Alignment(1);
}
impl ArkUI_Alignment {
    /// Top end.
    pub const ARKUI_ALIGNMENT_TOP_END: ArkUI_Alignment = ArkUI_Alignment(2);
}
impl ArkUI_Alignment {
    /// Vertically centered start.
    pub const ARKUI_ALIGNMENT_START: ArkUI_Alignment = ArkUI_Alignment(3);
}
impl ArkUI_Alignment {
    /// Horizontally and vertically centered.
    pub const ARKUI_ALIGNMENT_CENTER: ArkUI_Alignment = ArkUI_Alignment(4);
}
impl ArkUI_Alignment {
    /// Vertically centered end.
    pub const ARKUI_ALIGNMENT_END: ArkUI_Alignment = ArkUI_Alignment(5);
}
impl ArkUI_Alignment {
    /// Bottom start.
    pub const ARKUI_ALIGNMENT_BOTTOM_START: ArkUI_Alignment = ArkUI_Alignment(6);
}
impl ArkUI_Alignment {
    /// Horizontally centered on the bottom.
    pub const ARKUI_ALIGNMENT_BOTTOM: ArkUI_Alignment = ArkUI_Alignment(7);
}
impl ArkUI_Alignment {
    /// Bottom end.
    pub const ARKUI_ALIGNMENT_BOTTOM_END: ArkUI_Alignment = ArkUI_Alignment(8);
}
#[repr(transparent)]
/** @brief Enumerates the alignment modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_Alignment(pub ::core::ffi::c_uint);
impl ArkUI_ImageRepeat {
    /// The image is not repeatedly drawn.
    pub const ARKUI_IMAGE_REPEAT_NONE: ArkUI_ImageRepeat = ArkUI_ImageRepeat(0);
}
impl ArkUI_ImageRepeat {
    /// The image is repeatedly drawn only along the x-axis.
    pub const ARKUI_IMAGE_REPEAT_X: ArkUI_ImageRepeat = ArkUI_ImageRepeat(1);
}
impl ArkUI_ImageRepeat {
    /// The image is repeatedly drawn only along the y-axis.
    pub const ARKUI_IMAGE_REPEAT_Y: ArkUI_ImageRepeat = ArkUI_ImageRepeat(2);
}
impl ArkUI_ImageRepeat {
    /// The image is repeatedly drawn along both axes.
    pub const ARKUI_IMAGE_REPEAT_XY: ArkUI_ImageRepeat = ArkUI_ImageRepeat(3);
}
#[repr(transparent)]
/** @brief Enumerates the image repeat patterns.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ImageRepeat(pub ::core::ffi::c_uint);
impl ArkUI_FontStyle {
    /// Standard font style.
    pub const ARKUI_FONT_STYLE_NORMAL: ArkUI_FontStyle = ArkUI_FontStyle(0);
}
impl ArkUI_FontStyle {
    /// Italic font style.
    pub const ARKUI_FONT_STYLE_ITALIC: ArkUI_FontStyle = ArkUI_FontStyle(1);
}
#[repr(transparent)]
/** @brief Enumerates the font styles.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_FontStyle(pub ::core::ffi::c_uint);
impl ArkUI_FontWeight {
    /// 100
    pub const ARKUI_FONT_WEIGHT_W100: ArkUI_FontWeight = ArkUI_FontWeight(0);
}
impl ArkUI_FontWeight {
    /// 200
    pub const ARKUI_FONT_WEIGHT_W200: ArkUI_FontWeight = ArkUI_FontWeight(1);
}
impl ArkUI_FontWeight {
    /// 300
    pub const ARKUI_FONT_WEIGHT_W300: ArkUI_FontWeight = ArkUI_FontWeight(2);
}
impl ArkUI_FontWeight {
    /// 400
    pub const ARKUI_FONT_WEIGHT_W400: ArkUI_FontWeight = ArkUI_FontWeight(3);
}
impl ArkUI_FontWeight {
    /// 500
    pub const ARKUI_FONT_WEIGHT_W500: ArkUI_FontWeight = ArkUI_FontWeight(4);
}
impl ArkUI_FontWeight {
    /// 600
    pub const ARKUI_FONT_WEIGHT_W600: ArkUI_FontWeight = ArkUI_FontWeight(5);
}
impl ArkUI_FontWeight {
    /// 700
    pub const ARKUI_FONT_WEIGHT_W700: ArkUI_FontWeight = ArkUI_FontWeight(6);
}
impl ArkUI_FontWeight {
    /// 800
    pub const ARKUI_FONT_WEIGHT_W800: ArkUI_FontWeight = ArkUI_FontWeight(7);
}
impl ArkUI_FontWeight {
    /// 900
    pub const ARKUI_FONT_WEIGHT_W900: ArkUI_FontWeight = ArkUI_FontWeight(8);
}
impl ArkUI_FontWeight {
    /// The font weight is bold.
    pub const ARKUI_FONT_WEIGHT_BOLD: ArkUI_FontWeight = ArkUI_FontWeight(9);
}
impl ArkUI_FontWeight {
    /// The font weight is normal.
    pub const ARKUI_FONT_WEIGHT_NORMAL: ArkUI_FontWeight = ArkUI_FontWeight(10);
}
impl ArkUI_FontWeight {
    /// The font weight is bolder.
    pub const ARKUI_FONT_WEIGHT_BOLDER: ArkUI_FontWeight = ArkUI_FontWeight(11);
}
impl ArkUI_FontWeight {
    /// The font weight is lighter.
    pub const ARKUI_FONT_WEIGHT_LIGHTER: ArkUI_FontWeight = ArkUI_FontWeight(12);
}
impl ArkUI_FontWeight {
    /// The font weight is medium.
    pub const ARKUI_FONT_WEIGHT_MEDIUM: ArkUI_FontWeight = ArkUI_FontWeight(13);
}
impl ArkUI_FontWeight {
    /// The font weight is normal.
    pub const ARKUI_FONT_WEIGHT_REGULAR: ArkUI_FontWeight = ArkUI_FontWeight(14);
}
#[repr(transparent)]
/** @brief Enumerates the font weights.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_FontWeight(pub ::core::ffi::c_uint);
impl ArkUI_TextAlignment {
    /// Aligned with the start.
    pub const ARKUI_TEXT_ALIGNMENT_START: ArkUI_TextAlignment = ArkUI_TextAlignment(0);
}
impl ArkUI_TextAlignment {
    /// Horizontally centered.
    pub const ARKUI_TEXT_ALIGNMENT_CENTER: ArkUI_TextAlignment = ArkUI_TextAlignment(1);
}
impl ArkUI_TextAlignment {
    /// Aligned with the end.
    pub const ARKUI_TEXT_ALIGNMENT_END: ArkUI_TextAlignment = ArkUI_TextAlignment(2);
}
impl ArkUI_TextAlignment {
    /// Aligned with both margins.
    pub const ARKUI_TEXT_ALIGNMENT_JUSTIFY: ArkUI_TextAlignment = ArkUI_TextAlignment(3);
}
#[repr(transparent)]
/** @brief Enumerates the text alignment mode.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextAlignment(pub ::core::ffi::c_uint);
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "Go."
    pub const ARKUI_ENTER_KEY_TYPE_GO: ArkUI_EnterKeyType = ArkUI_EnterKeyType(2);
}
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "Search."
    pub const ARKUI_ENTER_KEY_TYPE_SEARCH: ArkUI_EnterKeyType = ArkUI_EnterKeyType(3);
}
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "Send."
    pub const ARKUI_ENTER_KEY_TYPE_SEND: ArkUI_EnterKeyType = ArkUI_EnterKeyType(4);
}
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "Next."
    pub const ARKUI_ENTER_KEY_TYPE_NEXT: ArkUI_EnterKeyType = ArkUI_EnterKeyType(5);
}
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "Done."
    pub const ARKUI_ENTER_KEY_TYPE_DONE: ArkUI_EnterKeyType = ArkUI_EnterKeyType(6);
}
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "Previous."
    pub const ARKUI_ENTER_KEY_TYPE_PREVIOUS: ArkUI_EnterKeyType = ArkUI_EnterKeyType(7);
}
impl ArkUI_EnterKeyType {
    /// The Enter key is labeled "New Line."
    pub const ARKUI_ENTER_KEY_TYPE_NEW_LINE: ArkUI_EnterKeyType = ArkUI_EnterKeyType(8);
}
#[repr(transparent)]
/** @brief Enumerates the types of the Enter key for a single-line text box.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_EnterKeyType(pub ::core::ffi::c_uint);
impl ArkUI_TextInputType {
    /// Normal input mode.
    pub const ARKUI_TEXTINPUT_TYPE_NORMAL: ArkUI_TextInputType = ArkUI_TextInputType(0);
}
impl ArkUI_TextInputType {
    /// Number input mode.
    pub const ARKUI_TEXTINPUT_TYPE_NUMBER: ArkUI_TextInputType = ArkUI_TextInputType(2);
}
impl ArkUI_TextInputType {
    /// Phone number input mode.
    pub const ARKUI_TEXTINPUT_TYPE_PHONE_NUMBER: ArkUI_TextInputType = ArkUI_TextInputType(3);
}
impl ArkUI_TextInputType {
    /// Email address input mode.
    pub const ARKUI_TEXTINPUT_TYPE_EMAIL: ArkUI_TextInputType = ArkUI_TextInputType(5);
}
impl ArkUI_TextInputType {
    /// Password input mode.
    pub const ARKUI_TEXTINPUT_TYPE_PASSWORD: ArkUI_TextInputType = ArkUI_TextInputType(7);
}
impl ArkUI_TextInputType {
    /// Numeric password input mode.
    pub const ARKUI_TEXTINPUT_TYPE_NUMBER_PASSWORD: ArkUI_TextInputType = ArkUI_TextInputType(8);
}
impl ArkUI_TextInputType {
    /// Lock screen password input mode.
    pub const ARKUI_TEXTINPUT_TYPE_SCREEN_LOCK_PASSWORD: ArkUI_TextInputType =
        ArkUI_TextInputType(9);
}
impl ArkUI_TextInputType {
    /// Username input mode.
    pub const ARKUI_TEXTINPUT_TYPE_USER_NAME: ArkUI_TextInputType = ArkUI_TextInputType(10);
}
impl ArkUI_TextInputType {
    /// New password input mode.
    pub const ARKUI_TEXTINPUT_TYPE_NEW_PASSWORD: ArkUI_TextInputType = ArkUI_TextInputType(11);
}
impl ArkUI_TextInputType {
    /// Number input mode with a decimal point.
    pub const ARKUI_TEXTINPUT_TYPE_NUMBER_DECIMAL: ArkUI_TextInputType = ArkUI_TextInputType(12);
}
#[repr(transparent)]
/** @brief Enumerates the text input types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextInputType(pub ::core::ffi::c_uint);
impl ArkUI_TextAreaType {
    /// Normal input mode.
    pub const ARKUI_TEXTAREA_TYPE_NORMAL: ArkUI_TextAreaType = ArkUI_TextAreaType(0);
}
impl ArkUI_TextAreaType {
    /// Number input mode.
    pub const ARKUI_TEXTAREA_TYPE_NUMBER: ArkUI_TextAreaType = ArkUI_TextAreaType(2);
}
impl ArkUI_TextAreaType {
    /// Phone number input mode.
    pub const ARKUI_TEXTAREA_TYPE_PHONE_NUMBER: ArkUI_TextAreaType = ArkUI_TextAreaType(3);
}
impl ArkUI_TextAreaType {
    /// Email address input mode.
    pub const ARKUI_TEXTAREA_TYPE_EMAIL: ArkUI_TextAreaType = ArkUI_TextAreaType(5);
}
#[repr(transparent)]
/** @brief Enumerates the text box types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextAreaType(pub ::core::ffi::c_uint);
impl ArkUI_CancelButtonStyle {
    /// The Cancel button is always displayed.
    pub const ARKUI_CANCELBUTTON_STYLE_CONSTANT: ArkUI_CancelButtonStyle =
        ArkUI_CancelButtonStyle(0);
}
impl ArkUI_CancelButtonStyle {
    /// The Cancel button is always hidden.
    pub const ARKUI_CANCELBUTTON_STYLE_INVISIBLE: ArkUI_CancelButtonStyle =
        ArkUI_CancelButtonStyle(1);
}
impl ArkUI_CancelButtonStyle {
    /// The Cancel button is displayed when there is text input.
    pub const ARKUI_CANCELBUTTON_STYLE_INPUT: ArkUI_CancelButtonStyle = ArkUI_CancelButtonStyle(2);
}
#[repr(transparent)]
/** @brief Enumerates the styles of the Cancel button.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_CancelButtonStyle(pub ::core::ffi::c_uint);
impl ArkUI_XComponentType {
    /// The custom content of EGL/OpenGL ES and media data is displayed individually on the screen.
    pub const ARKUI_XCOMPONENT_TYPE_SURFACE: ArkUI_XComponentType = ArkUI_XComponentType(0);
}
impl ArkUI_XComponentType {
    /** The custom content of EGL/OpenGL ES and media data is grouped and displayed together with content
    of the component.*/
    pub const ARKUI_XCOMPONENT_TYPE_TEXTURE: ArkUI_XComponentType = ArkUI_XComponentType(2);
}
#[repr(transparent)]
/** @brief Enumerates the types of the <b><XComponent></b> component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_XComponentType(pub ::core::ffi::c_uint);
impl ArkUI_ProgressType {
    /// Linear style.
    pub const ARKUI_PROGRESS_TYPE_LINEAR: ArkUI_ProgressType = ArkUI_ProgressType(0);
}
impl ArkUI_ProgressType {
    /// Indeterminate ring style.
    pub const ARKUI_PROGRESS_TYPE_RING: ArkUI_ProgressType = ArkUI_ProgressType(1);
}
impl ArkUI_ProgressType {
    /// Eclipse style.
    pub const ARKUI_PROGRESS_TYPE_ECLIPSE: ArkUI_ProgressType = ArkUI_ProgressType(2);
}
impl ArkUI_ProgressType {
    /// Determinate ring style.
    pub const ARKUI_PROGRESS_TYPE_SCALE_RING: ArkUI_ProgressType = ArkUI_ProgressType(3);
}
impl ArkUI_ProgressType {
    /// Capsule style.
    pub const ARKUI_PROGRESS_TYPE_CAPSULE: ArkUI_ProgressType = ArkUI_ProgressType(4);
}
#[repr(transparent)]
/** @brief Enumerates the styles of the progress indicator.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ProgressType(pub ::core::ffi::c_uint);
impl ArkUI_TextDecorationType {
    /// No text decoration.
    pub const ARKUI_TEXT_DECORATION_TYPE_NONE: ArkUI_TextDecorationType =
        ArkUI_TextDecorationType(0);
}
impl ArkUI_TextDecorationType {
    /// Line under the text.
    pub const ARKUI_TEXT_DECORATION_TYPE_UNDERLINE: ArkUI_TextDecorationType =
        ArkUI_TextDecorationType(1);
}
impl ArkUI_TextDecorationType {
    /// Line over the text.
    pub const ARKUI_TEXT_DECORATION_TYPE_OVERLINE: ArkUI_TextDecorationType =
        ArkUI_TextDecorationType(2);
}
impl ArkUI_TextDecorationType {
    /// Line through the text.
    pub const ARKUI_TEXT_DECORATION_TYPE_LINE_THROUGH: ArkUI_TextDecorationType =
        ArkUI_TextDecorationType(3);
}
#[repr(transparent)]
/** @brief Enumerates the text decoration types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextDecorationType(pub ::core::ffi::c_uint);
impl ArkUI_TextDecorationStyle {
    /// Single solid line.
    pub const ARKUI_TEXT_DECORATION_STYLE_SOLID: ArkUI_TextDecorationStyle =
        ArkUI_TextDecorationStyle(0);
}
impl ArkUI_TextDecorationStyle {
    /// Double solid line.
    pub const ARKUI_TEXT_DECORATION_STYLE_DOUBLE: ArkUI_TextDecorationStyle =
        ArkUI_TextDecorationStyle(1);
}
impl ArkUI_TextDecorationStyle {
    /// Dotted line.
    pub const ARKUI_TEXT_DECORATION_STYLE_DOTTED: ArkUI_TextDecorationStyle =
        ArkUI_TextDecorationStyle(2);
}
impl ArkUI_TextDecorationStyle {
    /// Dashed line.
    pub const ARKUI_TEXT_DECORATION_STYLE_DASHED: ArkUI_TextDecorationStyle =
        ArkUI_TextDecorationStyle(3);
}
impl ArkUI_TextDecorationStyle {
    /// Wavy line.
    pub const ARKUI_TEXT_DECORATION_STYLE_WAVY: ArkUI_TextDecorationStyle =
        ArkUI_TextDecorationStyle(4);
}
#[repr(transparent)]
/** @brief Enumerates the text decoration styles.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextDecorationStyle(pub ::core::ffi::c_uint);
impl ArkUI_TextCase {
    /// The original case of the text is retained.
    pub const ARKUI_TEXT_CASE_NORMAL: ArkUI_TextCase = ArkUI_TextCase(0);
}
impl ArkUI_TextCase {
    /// All letters in the text are in lowercase.
    pub const ARKUI_TEXT_CASE_LOWER: ArkUI_TextCase = ArkUI_TextCase(1);
}
impl ArkUI_TextCase {
    /// All letters in the text are in uppercase.
    pub const ARKUI_TEXT_CASE_UPPER: ArkUI_TextCase = ArkUI_TextCase(2);
}
#[repr(transparent)]
/** @brief Enumerates the text cases.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextCase(pub ::core::ffi::c_uint);
impl ArkUI_CopyOptions {
    /// Copy is not allowed.
    pub const ARKUI_COPY_OPTIONS_NONE: ArkUI_CopyOptions = ArkUI_CopyOptions(0);
}
impl ArkUI_CopyOptions {
    /// Intra-application copy is allowed.
    pub const ARKUI_COPY_OPTIONS_IN_APP: ArkUI_CopyOptions = ArkUI_CopyOptions(1);
}
impl ArkUI_CopyOptions {
    /// Intra-device copy is allowed.
    pub const ARKUI_COPY_OPTIONS_LOCAL_DEVICE: ArkUI_CopyOptions = ArkUI_CopyOptions(2);
}
impl ArkUI_CopyOptions {
    /// Cross-device copy is allowed.
    pub const ARKUI_COPY_OPTIONS_CROSS_DEVICE: ArkUI_CopyOptions = ArkUI_CopyOptions(3);
}
#[repr(transparent)]
/** @brief Enumerates the text copy and paste modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_CopyOptions(pub ::core::ffi::c_uint);
impl ArkUI_ShadowType {
    /// Color.
    pub const ARKUI_SHADOW_TYPE_COLOR: ArkUI_ShadowType = ArkUI_ShadowType(0);
}
impl ArkUI_ShadowType {
    /// Blur.
    pub const ARKUI_SHADOW_TYPE_BLUR: ArkUI_ShadowType = ArkUI_ShadowType(1);
}
#[repr(transparent)]
/** @brief Enumerates the shadow types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ShadowType(pub ::core::ffi::c_uint);
impl ArkUI_TextPickerRangeType {
    /// Single-column text picker.
    pub const ARKUI_TEXTPICKER_RANGETYPE_SINGLE: ArkUI_TextPickerRangeType =
        ArkUI_TextPickerRangeType(0);
}
impl ArkUI_TextPickerRangeType {
    /// Multi-column text picker.
    pub const ARKUI_TEXTPICKER_RANGETYPE_MULTI: ArkUI_TextPickerRangeType =
        ArkUI_TextPickerRangeType(1);
}
impl ArkUI_TextPickerRangeType {
    /// Single-column text picker with image resources.
    pub const ARKUI_TEXTPICKER_RANGETYPE_RANGE_CONTENT: ArkUI_TextPickerRangeType =
        ArkUI_TextPickerRangeType(2);
}
impl ArkUI_TextPickerRangeType {
    /// Interconnected multi-column text picker.
    pub const ARKUI_TEXTPICKER_RANGETYPE_CASCADE_RANGE_CONTENT: ArkUI_TextPickerRangeType =
        ArkUI_TextPickerRangeType(3);
}
#[repr(transparent)]
/** @brief Enumerates the types of the text picker.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextPickerRangeType(pub ::core::ffi::c_uint);
/** @brief Defines the input structure of the single-column text picker with image resources.

@since 12*/
#[repr(C)]
pub struct ARKUI_TextPickerRangeContent {
    /// Image resource.
    pub icon: *const ::core::ffi::c_char,
    /// Text information.
    pub text: *const ::core::ffi::c_char,
}
/** @brief Defines the input structure of the interconnected multi-column text picker.

@since 12*/
#[repr(C)]
pub struct ARKUI_TextPickerCascadeRangeContent {
    /// Text information.
    pub text: *const ::core::ffi::c_char,
    /// Interconnected data.
    pub children: *const ARKUI_TextPickerRangeContent,
    /// Size of the interconnected data array.
    pub size: i32,
}
impl ArkUI_EdgeEffect {
    /** Spring effect. When at one of the edges, the component can move beyond the bounds based on the initial
    speed or through touches, and produces a bounce effect when the user releases their finger.*/
    pub const ARKUI_EDGE_EFFECT_SPRING: ArkUI_EdgeEffect = ArkUI_EdgeEffect(0);
}
impl ArkUI_EdgeEffect {
    /// Fade effect. When at one of the edges, the component produces a fade effect.
    pub const ARKUI_EDGE_EFFECT_FADE: ArkUI_EdgeEffect = ArkUI_EdgeEffect(1);
}
impl ArkUI_EdgeEffect {
    /// No effect after the scrollbar is moved to the edge.
    pub const ARKUI_EDGE_EFFECT_NONE: ArkUI_EdgeEffect = ArkUI_EdgeEffect(2);
}
#[repr(transparent)]
/** @brief Enumerates the effects used at the edges of the component when the boundary of the scrollable content is
reached.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_EdgeEffect(pub ::core::ffi::c_uint);
impl ArkUI_ScrollDirection {
    /// Only vertical scrolling is supported.
    pub const ARKUI_SCROLL_DIRECTION_VERTICAL: ArkUI_ScrollDirection = ArkUI_ScrollDirection(0);
}
impl ArkUI_ScrollDirection {
    /// Only horizontal scrolling is supported.
    pub const ARKUI_SCROLL_DIRECTION_HORIZONTAL: ArkUI_ScrollDirection = ArkUI_ScrollDirection(1);
}
impl ArkUI_ScrollDirection {
    /// Scrolling is not allowed.
    pub const ARKUI_SCROLL_DIRECTION_NONE: ArkUI_ScrollDirection = ArkUI_ScrollDirection(3);
}
#[repr(transparent)]
/** @brief Enumerates the scroll directions for the <b><Scroll></b> component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollDirection(pub ::core::ffi::c_uint);
impl ArkUI_ScrollSnapAlign {
    /// No alignment. This is the default value.
    pub const ARKUI_SCROLL_SNAP_ALIGN_NONE: ArkUI_ScrollSnapAlign = ArkUI_ScrollSnapAlign(0);
}
impl ArkUI_ScrollSnapAlign {
    /// The first item in the view is aligned at the start of the list.
    pub const ARKUI_SCROLL_SNAP_ALIGN_START: ArkUI_ScrollSnapAlign = ArkUI_ScrollSnapAlign(1);
}
impl ArkUI_ScrollSnapAlign {
    /// The middle items in the view are aligned in the center of the list.
    pub const ARKUI_SCROLL_SNAP_ALIGN_CENTER: ArkUI_ScrollSnapAlign = ArkUI_ScrollSnapAlign(2);
}
impl ArkUI_ScrollSnapAlign {
    /// The last item in the view is aligned at the end of the list.
    pub const ARKUI_SCROLL_SNAP_ALIGN_END: ArkUI_ScrollSnapAlign = ArkUI_ScrollSnapAlign(3);
}
#[repr(transparent)]
/** @brief Enumerates the alignment modes of list items when scrolling ends.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollSnapAlign(pub ::core::ffi::c_uint);
impl ArkUI_ScrollBarDisplayMode {
    /// Hide.
    pub const ARKUI_SCROLL_BAR_DISPLAY_MODE_OFF: ArkUI_ScrollBarDisplayMode =
        ArkUI_ScrollBarDisplayMode(0);
}
impl ArkUI_ScrollBarDisplayMode {
    /// Display on demand (displays when the screen is touched and disappears after 2s).
    pub const ARKUI_SCROLL_BAR_DISPLAY_MODE_AUTO: ArkUI_ScrollBarDisplayMode =
        ArkUI_ScrollBarDisplayMode(1);
}
impl ArkUI_ScrollBarDisplayMode {
    /// Always display.
    pub const ARKUI_SCROLL_BAR_DISPLAY_MODE_ON: ArkUI_ScrollBarDisplayMode =
        ArkUI_ScrollBarDisplayMode(2);
}
#[repr(transparent)]
/** @brief Enumerates the scrollbar display modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollBarDisplayMode(pub ::core::ffi::c_uint);
impl ArkUI_Axis {
    /// Only vertical scrolling is supported.
    pub const ARKUI_AXIS_VERTICAL: ArkUI_Axis = ArkUI_Axis(0);
}
impl ArkUI_Axis {
    /// Only horizontal scrolling is supported.
    pub const ARKUI_AXIS_HORIZONTAL: ArkUI_Axis = ArkUI_Axis(1);
}
#[repr(transparent)]
/** @brief Enumerates the scroll directions for the <b><List></b> component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_Axis(pub ::core::ffi::c_uint);
impl ArkUI_StickyStyle {
    /// In the list item group, the header is not pinned to the top, and the footer is not pinned to the bottom.
    pub const ARKUI_STICKY_STYLE_NONE: ArkUI_StickyStyle = ArkUI_StickyStyle(0);
}
impl ArkUI_StickyStyle {
    /// In the list item group, the header is pinned to the top, and the footer is not pinned to the bottom.
    pub const ARKUI_STICKY_STYLE_HEADER: ArkUI_StickyStyle = ArkUI_StickyStyle(1);
}
impl ArkUI_StickyStyle {
    /// In the list item group, the footer is pinned to the bottom, and the header is not pinned to the top.
    pub const ARKUI_STICKY_STYLE_FOOTER: ArkUI_StickyStyle = ArkUI_StickyStyle(2);
}
impl ArkUI_StickyStyle {
    /// In the list item group, the footer is pinned to the bottom, and the header is pinned to the top.
    pub const ARKUI_STICKY_STYLE_BOTH: ArkUI_StickyStyle = ArkUI_StickyStyle(3);
}
#[repr(transparent)]
/** @brief Enumerates the modes for pinning the header to the top or the footer to the bottom.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_StickyStyle(pub ::core::ffi::c_uint);
impl ArkUI_BorderStyle {
    /// Solid border.
    pub const ARKUI_BORDER_STYLE_SOLID: ArkUI_BorderStyle = ArkUI_BorderStyle(0);
}
impl ArkUI_BorderStyle {
    /// Dashed border.
    pub const ARKUI_BORDER_STYLE_DASHED: ArkUI_BorderStyle = ArkUI_BorderStyle(1);
}
impl ArkUI_BorderStyle {
    /// Dotted border.
    pub const ARKUI_BORDER_STYLE_DOTTED: ArkUI_BorderStyle = ArkUI_BorderStyle(2);
}
#[repr(transparent)]
/** @brief Enumerates the border styles.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_BorderStyle(pub ::core::ffi::c_uint);
impl ArkUI_HitTestMode {
    /** Both the node and its child node respond to the hit test of a touch event, but its sibling node is blocked from
    the hit test.*/
    pub const ARKUI_HIT_TEST_MODE_DEFAULT: ArkUI_HitTestMode = ArkUI_HitTestMode(0);
}
impl ArkUI_HitTestMode {
    /** The node responds to the hit test of a touch event, but its child node and sibling node are blocked from the
    hit test.*/
    pub const ARKUI_HIT_TEST_MODE_BLOCK: ArkUI_HitTestMode = ArkUI_HitTestMode(1);
}
impl ArkUI_HitTestMode {
    /** Both the node and its child node respond to the hit test of a touch event, and its sibling node is also
    considered during the hit test.*/
    pub const ARKUI_HIT_TEST_MODE_TRANSPARENT: ArkUI_HitTestMode = ArkUI_HitTestMode(2);
}
impl ArkUI_HitTestMode {
    /// The node does not respond to the hit test of a touch event.
    pub const ARKUI_HIT_TEST_MODE_NONE: ArkUI_HitTestMode = ArkUI_HitTestMode(3);
}
#[repr(transparent)]
/** @brief Enumerates the hit test modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_HitTestMode(pub ::core::ffi::c_uint);
impl ArkUI_ShadowStyle {
    /// Mini shadow.
    pub const ARKUI_SHADOW_STYLE_OUTER_DEFAULT_XS: ArkUI_ShadowStyle = ArkUI_ShadowStyle(0);
}
impl ArkUI_ShadowStyle {
    /// Little shadow.
    pub const ARKUI_SHADOW_STYLE_OUTER_DEFAULT_SM: ArkUI_ShadowStyle = ArkUI_ShadowStyle(1);
}
impl ArkUI_ShadowStyle {
    /// Medium shadow.
    pub const ARKUI_SHADOW_STYLE_OUTER_DEFAULT_MD: ArkUI_ShadowStyle = ArkUI_ShadowStyle(2);
}
impl ArkUI_ShadowStyle {
    /// Large shadow.
    pub const ARKUI_SHADOW_STYLE_OUTER_DEFAULT_LG: ArkUI_ShadowStyle = ArkUI_ShadowStyle(3);
}
impl ArkUI_ShadowStyle {
    /// Floating small shadow.
    pub const ARKUI_SHADOW_STYLE_OUTER_FLOATING_SM: ArkUI_ShadowStyle = ArkUI_ShadowStyle(4);
}
impl ArkUI_ShadowStyle {
    /// Floating medium shadow.
    pub const ARKUI_SHADOW_STYLE_OUTER_FLOATING_MD: ArkUI_ShadowStyle = ArkUI_ShadowStyle(5);
}
#[repr(transparent)]
/** @brief Enumerates the shadow styles.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ShadowStyle(pub ::core::ffi::c_uint);
impl ArkUI_AnimationCurve {
    /// The animation speed keeps unchanged.
    pub const ARKUI_CURVE_LINEAR: ArkUI_AnimationCurve = ArkUI_AnimationCurve(0);
}
impl ArkUI_AnimationCurve {
    /// The animation starts slowly, accelerates, and then slows down towards the end.
    pub const ARKUI_CURVE_EASE: ArkUI_AnimationCurve = ArkUI_AnimationCurve(1);
}
impl ArkUI_AnimationCurve {
    /// The animation starts at a low speed and then picks up speed until the end.
    pub const ARKUI_CURVE_EASE_IN: ArkUI_AnimationCurve = ArkUI_AnimationCurve(2);
}
impl ArkUI_AnimationCurve {
    /// The animation ends at a low speed.
    pub const ARKUI_CURVE_EASE_OUT: ArkUI_AnimationCurve = ArkUI_AnimationCurve(3);
}
impl ArkUI_AnimationCurve {
    /// The animation starts and ends at a low speed.
    pub const ARKUI_CURVE_EASE_IN_OUT: ArkUI_AnimationCurve = ArkUI_AnimationCurve(4);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the standard curve
    pub const ARKUI_CURVE_FAST_OUT_SLOW_IN: ArkUI_AnimationCurve = ArkUI_AnimationCurve(5);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the deceleration curve.
    pub const ARKUI_CURVE_LINEAR_OUT_SLOW_IN: ArkUI_AnimationCurve = ArkUI_AnimationCurve(6);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the acceleration curve.
    pub const ARKUI_CURVE_FAST_OUT_LINEAR_IN: ArkUI_AnimationCurve = ArkUI_AnimationCurve(7);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the extreme deceleration curve.
    pub const ARKUI_CURVE_EXTREME_DECELERATION: ArkUI_AnimationCurve = ArkUI_AnimationCurve(8);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the sharp curve.
    pub const ARKUI_CURVE_SHARP: ArkUI_AnimationCurve = ArkUI_AnimationCurve(9);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the rhythm curve.
    pub const ARKUI_CURVE_RHYTHM: ArkUI_AnimationCurve = ArkUI_AnimationCurve(10);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the smooth curve.
    pub const ARKUI_CURVE_SMOOTH: ArkUI_AnimationCurve = ArkUI_AnimationCurve(11);
}
impl ArkUI_AnimationCurve {
    /// The animation uses the friction curve
    pub const ARKUI_CURVE_FRICTION: ArkUI_AnimationCurve = ArkUI_AnimationCurve(12);
}
#[repr(transparent)]
/** @brief Enumerates the animation curves.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AnimationCurve(pub ::core::ffi::c_uint);
impl ArkUI_SwiperArrow {
    /// The arrow is not displayed for the navigation point indicator.
    pub const ARKUI_SWIPER_ARROW_HIDE: ArkUI_SwiperArrow = ArkUI_SwiperArrow(0);
}
impl ArkUI_SwiperArrow {
    /// The arrow is displayed for the navigation point indicator.
    pub const ARKUI_SWIPER_ARROW_SHOW: ArkUI_SwiperArrow = ArkUI_SwiperArrow(1);
}
impl ArkUI_SwiperArrow {
    /// The arrow is displayed only when the mouse pointer hovers over the navigation point indicator.
    pub const ARKUI_SWIPER_ARROW_SHOW_ON_HOVER: ArkUI_SwiperArrow = ArkUI_SwiperArrow(2);
}
#[repr(transparent)]
/** @brief Enumerates arrow styles of the navigation point indicator.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SwiperArrow(pub ::core::ffi::c_uint);
impl ArkUI_SwiperNestedScrollMode {
    /// Swiper only scrolls on its own and is not linked to its parent component.
    pub const ARKUI_SWIPER_NESTED_SRCOLL_SELF_ONLY: ArkUI_SwiperNestedScrollMode =
        ArkUI_SwiperNestedScrollMode(0);
}
impl ArkUI_SwiperNestedScrollMode {
    /** The Swiper itself scrolls first, and the parent component scrolls after it reaches the edge. After the parent
    component scrolls to the edge, if the parent component has an edge effect, the parent component triggers the edge
    effect; otherwise, the Swiper triggers the edge effect.*/
    pub const ARKUI_SWIPER_NESTED_SRCOLL_SELF_FIRST: ArkUI_SwiperNestedScrollMode =
        ArkUI_SwiperNestedScrollMode(1);
}
#[repr(transparent)]
/** @brief Nested scrolling mode for Swiper components and parent components.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SwiperNestedScrollMode(pub ::core::ffi::c_uint);
impl ArkUI_AccessibilityMode {
    /// Whether the component can be identified by the accessibility service is dependent on the component.
    pub const ARKUI_ACCESSIBILITY_MODE_AUTO: ArkUI_AccessibilityMode = ArkUI_AccessibilityMode(0);
}
impl ArkUI_AccessibilityMode {
    /// The component can be identified by the accessibility service.
    pub const ARKUI_ACCESSIBILITY_MODE_ENABLED: ArkUI_AccessibilityMode =
        ArkUI_AccessibilityMode(1);
}
impl ArkUI_AccessibilityMode {
    /// The component cannot be identified by the accessibility service.
    pub const ARKUI_ACCESSIBILITY_MODE_DISABLED: ArkUI_AccessibilityMode =
        ArkUI_AccessibilityMode(2);
}
impl ArkUI_AccessibilityMode {
    /// The component and all its child components cannot be identified by the accessibility service.
    pub const ARKUI_ACCESSIBILITY_MODE_DISABLED_FOR_DESCENDANTS: ArkUI_AccessibilityMode =
        ArkUI_AccessibilityMode(3);
}
#[repr(transparent)]
/** @brief Enumerates the accessibility modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AccessibilityMode(pub ::core::ffi::c_uint);
impl ArkUI_TextCopyOptions {
    /// Copy is not allowed.
    pub const ARKUI_TEXT_COPY_OPTIONS_NONE: ArkUI_TextCopyOptions = ArkUI_TextCopyOptions(0);
}
impl ArkUI_TextCopyOptions {
    /// Intra-application copy is allowed.
    pub const ARKUI_TEXT_COPY_OPTIONS_IN_APP: ArkUI_TextCopyOptions = ArkUI_TextCopyOptions(1);
}
impl ArkUI_TextCopyOptions {
    /// Intra-device copy is allowed.
    pub const ARKUI_TEXT_COPY_OPTIONS_LOCAL_DEVICE: ArkUI_TextCopyOptions =
        ArkUI_TextCopyOptions(2);
}
impl ArkUI_TextCopyOptions {
    /// Cross-device copy is allowed.
    pub const ARKUI_TEXT_COPY_OPTIONS_CROSS_DEVICE: ArkUI_TextCopyOptions =
        ArkUI_TextCopyOptions(3);
}
#[repr(transparent)]
/** @brief Defines whether copy and paste is allowed for text content.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextCopyOptions(pub ::core::ffi::c_uint);
impl ArkUI_TextHeightAdaptivePolicy {
    /// Prioritize the <b>maxLines</b> settings.
    pub const ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_MAX_LINES_FIRST: ArkUI_TextHeightAdaptivePolicy =
        ArkUI_TextHeightAdaptivePolicy(0);
}
impl ArkUI_TextHeightAdaptivePolicy {
    /// Prioritize the <b>minFontSize</b> settings.
    pub const ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_MIN_FONT_SIZE_FIRST:
        ArkUI_TextHeightAdaptivePolicy = ArkUI_TextHeightAdaptivePolicy(1);
}
impl ArkUI_TextHeightAdaptivePolicy {
    /// Prioritize the layout constraint settings in terms of height.
    pub const ARKUI_TEXT_HEIGHT_ADAPTIVE_POLICY_LAYOUT_CONSTRAINT_FIRST:
        ArkUI_TextHeightAdaptivePolicy = ArkUI_TextHeightAdaptivePolicy(2);
}
#[repr(transparent)]
/** @brief Defines how the adaptive height is determined for the text.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextHeightAdaptivePolicy(pub ::core::ffi::c_uint);
impl ArkUI_ScrollNestedMode {
    /** The scrolling is contained within the component, and no scroll chaining occurs, that is, the parent component
    does not scroll when the component scrolling reaches the boundary.*/
    pub const ARKUI_SCROLL_NESTED_MODE_SELF_ONLY: ArkUI_ScrollNestedMode =
        ArkUI_ScrollNestedMode(0);
}
impl ArkUI_ScrollNestedMode {
    #[doc = " The component scrolls first, and when it hits the boundary, the parent component scrolls.\n/** When the parent component hits the boundary, its edge effect is displayed. If no edge\n  effect is specified for the parent component, the edge effect of the child component is displayed instead."]
    pub const ARKUI_SCROLL_NESTED_MODE_SELF_FIRST: ArkUI_ScrollNestedMode =
        ArkUI_ScrollNestedMode(1);
}
impl ArkUI_ScrollNestedMode {
    /** The parent component scrolls first, and when it hits the boundary, the component scrolls.
    When the component hits the boundary, its edge effect is displayed. If no edge effect is specified for the
    component, the edge effect of the parent component is displayed instead.*/
    pub const ARKUI_SCROLL_NESTED_MODE_PARENT_FIRST: ArkUI_ScrollNestedMode =
        ArkUI_ScrollNestedMode(2);
}
impl ArkUI_ScrollNestedMode {
    /** The component and its parent component scroll at the same time. When both the component and its parent component
    hit the boundary, the edge effect of the component is displayed. If no edge effect is specified for the
    component, the edge effect of the parent component is displayed instead.*/
    pub const ARKUI_SCROLL_NESTED_MODE_PARALLEL: ArkUI_ScrollNestedMode = ArkUI_ScrollNestedMode(3);
}
#[repr(transparent)]
/** @brief Defines nested scrolling options.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollNestedMode(pub ::core::ffi::c_uint);
impl ArkUI_ScrollEdge {
    /// Top edge in the vertical direction.
    pub const ARKUI_SCROLL_EDGE_TOP: ArkUI_ScrollEdge = ArkUI_ScrollEdge(0);
}
impl ArkUI_ScrollEdge {
    /// Bottom edge in the vertical direction.
    pub const ARKUI_SCROLL_EDGE_BOTTOM: ArkUI_ScrollEdge = ArkUI_ScrollEdge(1);
}
impl ArkUI_ScrollEdge {
    /// Start position in the horizontal direction.
    pub const ARKUI_SCROLL_EDGE_START: ArkUI_ScrollEdge = ArkUI_ScrollEdge(2);
}
impl ArkUI_ScrollEdge {
    /// End position in the horizontal direction.
    pub const ARKUI_SCROLL_EDGE_END: ArkUI_ScrollEdge = ArkUI_ScrollEdge(3);
}
#[repr(transparent)]
/** @brief Defines the edge to which the component scrolls.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollEdge(pub ::core::ffi::c_uint);
impl ArkUI_ScrollAlignment {
    /// Align the head. Align the head of the specified item with the head of the container.
    pub const ARKUI_SCROLL_ALIGNMENT_START: ArkUI_ScrollAlignment = ArkUI_ScrollAlignment(0);
}
impl ArkUI_ScrollAlignment {
    /// Center alignment. Align the axis direction of the specified item to the center of the container.
    pub const ARKUI_SCROLL_ALIGNMENT_CENTER: ArkUI_ScrollAlignment = ArkUI_ScrollAlignment(1);
}
impl ArkUI_ScrollAlignment {
    /// Tail alignment. Align the tail of the specified item with the tail of the container.
    pub const ARKUI_SCROLL_ALIGNMENT_END: ArkUI_ScrollAlignment = ArkUI_ScrollAlignment(2);
}
impl ArkUI_ScrollAlignment {
    /** Automatic alignment. If the specified item is completely in the display area, no adjustments will be made.
    Otherwise, according to the principle of the shortest sliding distance, align the head or tail of the specified
    item with the container, so that the specified item is completely in the display area.*/
    pub const ARKUI_SCROLL_ALIGNMENT_AUTO: ArkUI_ScrollAlignment = ArkUI_ScrollAlignment(3);
}
#[repr(transparent)]
/** @brief Alignment when scrolling to specific items.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollAlignment(pub ::core::ffi::c_uint);
impl ArkUI_ScrollState {
    /** Idle state. Trigger when using the method provided by the controller to control scrolling, and trigger when
    dragging the scroll bar to scroll.*/
    pub const ARKUI_SCROLL_STATE_IDLE: ArkUI_ScrollState = ArkUI_ScrollState(0);
}
impl ArkUI_ScrollState {
    /// Scroll state. Triggered when dragging the container with fingers to scroll.
    pub const ARKUI_SCROLL_STATE_SCROLL: ArkUI_ScrollState = ArkUI_ScrollState(1);
}
impl ArkUI_ScrollState {
    /** Inertial rolling state. Triggered when inertia rolling and bouncing back to the edge are performed after
    releasing the hand quickly.*/
    pub const ARKUI_SCROLL_STATE_FLING: ArkUI_ScrollState = ArkUI_ScrollState(2);
}
#[repr(transparent)]
/** @brief Define the current scrolling state.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollState(pub ::core::ffi::c_uint);
impl ArkUI_SliderBlockStyle {
    /// Round slider.
    pub const ARKUI_SLIDER_BLOCK_STYLE_DEFAULT: ArkUI_SliderBlockStyle = ArkUI_SliderBlockStyle(0);
}
impl ArkUI_SliderBlockStyle {
    /// Slider with an image background.
    pub const ARKUI_SLIDER_BLOCK_STYLE_IMAGE: ArkUI_SliderBlockStyle = ArkUI_SliderBlockStyle(1);
}
impl ArkUI_SliderBlockStyle {
    /// Slider in a custom shape.
    pub const ARKUI_SLIDER_BLOCK_STYLE_SHAPE: ArkUI_SliderBlockStyle = ArkUI_SliderBlockStyle(2);
}
#[repr(transparent)]
/** @brief Enumerates the types of the slider in the block direction.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SliderBlockStyle(pub ::core::ffi::c_uint);
impl ArkUI_SliderDirection {
    /// Vertical direction.
    pub const ARKUI_SLIDER_DIRECTION_VERTICAL: ArkUI_SliderDirection = ArkUI_SliderDirection(0);
}
impl ArkUI_SliderDirection {
    /// Horizontal direction.
    pub const ARKUI_SLIDER_DIRECTION_HORIZONTAL: ArkUI_SliderDirection = ArkUI_SliderDirection(1);
}
#[repr(transparent)]
/** @brief Enumerates the scroll directions of the slider.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SliderDirection(pub ::core::ffi::c_uint);
impl ArkUI_SliderStyle {
    /// The slider is on the slider track.
    pub const ARKUI_SLIDER_STYLE_OUT_SET: ArkUI_SliderStyle = ArkUI_SliderStyle(0);
}
impl ArkUI_SliderStyle {
    /// The slider is in the slider track.
    pub const ARKUI_SLIDER_STYLE_IN_SET: ArkUI_SliderStyle = ArkUI_SliderStyle(1);
}
impl ArkUI_SliderStyle {
    /// No slider.
    pub const ARKUI_SLIDER_STYLE_NONE: ArkUI_SliderStyle = ArkUI_SliderStyle(2);
}
#[repr(transparent)]
/** @brief Enumerates the slider styles.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SliderStyle(pub ::core::ffi::c_uint);
impl ArkUI_CheckboxShape {
    /// Circle.
    pub const ArkUI_CHECKBOX_SHAPE_CIRCLE: ArkUI_CheckboxShape = ArkUI_CheckboxShape(0);
}
impl ArkUI_CheckboxShape {
    /// Rounded square.
    pub const ArkUI_CHECKBOX_SHAPE_ROUNDED_SQUARE: ArkUI_CheckboxShape = ArkUI_CheckboxShape(1);
}
#[repr(transparent)]
/** @brief Enumerates the shapes of the check box

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_CheckboxShape(pub ::core::ffi::c_uint);
impl ArkUI_AnimationPlayMode {
    /// The animation is played forwards.
    pub const ARKUI_ANIMATION_PLAY_MODE_NORMAL: ArkUI_AnimationPlayMode =
        ArkUI_AnimationPlayMode(0);
}
impl ArkUI_AnimationPlayMode {
    /// The animation is played reversely.
    pub const ARKUI_ANIMATION_PLAY_MODE_REVERSE: ArkUI_AnimationPlayMode =
        ArkUI_AnimationPlayMode(1);
}
impl ArkUI_AnimationPlayMode {
    /** The animation is played normally for an odd number of times (1, 3, 5...) and reversely for an even number
    of times (2, 4, 6...).*/
    pub const ARKUI_ANIMATION_PLAY_MODE_ALTERNATE: ArkUI_AnimationPlayMode =
        ArkUI_AnimationPlayMode(2);
}
impl ArkUI_AnimationPlayMode {
    /** The animation is played reversely for an odd number of times (1, 3, 5...) and normally for an even number
    of times (2, 4, 6...).*/
    pub const ARKUI_ANIMATION_PLAY_MODE_ALTERNATE_REVERSE: ArkUI_AnimationPlayMode =
        ArkUI_AnimationPlayMode(3);
}
#[repr(transparent)]
/** @brief Enumerates the animation playback modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AnimationPlayMode(pub ::core::ffi::c_uint);
impl ArkUI_ImageSize {
    /// The original image aspect ratio is retained.
    pub const ARKUI_IMAGE_SIZE_AUTO: ArkUI_ImageSize = ArkUI_ImageSize(0);
}
impl ArkUI_ImageSize {
    /** Default value. The image is scaled with its aspect ratio retained for both sides to be greater than or equal
    to the display boundaries.*/
    pub const ARKUI_IMAGE_SIZE_COVER: ArkUI_ImageSize = ArkUI_ImageSize(1);
}
impl ArkUI_ImageSize {
    /** The image is scaled with its aspect ratio retained for the content to be completely displayed within the display
    boundaries.*/
    pub const ARKUI_IMAGE_SIZE_CONTAIN: ArkUI_ImageSize = ArkUI_ImageSize(2);
}
#[repr(transparent)]
/** @brief Defines the image size.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ImageSize(pub ::core::ffi::c_uint);
impl ArkUI_AdaptiveColor {
    /// Adaptive color mode is not used.
    pub const ARKUI_ADAPTIVE_COLOR_DEFAULT: ArkUI_AdaptiveColor = ArkUI_AdaptiveColor(0);
}
impl ArkUI_AdaptiveColor {
    /// Adaptive color mode is used.
    pub const ARKUI_ADAPTIVE_COLOR_AVERAGE: ArkUI_AdaptiveColor = ArkUI_AdaptiveColor(1);
}
#[repr(transparent)]
/** @brief Enumerates the adaptive color modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AdaptiveColor(pub ::core::ffi::c_uint);
impl ArkUI_ColorMode {
    /// Following the system color mode.
    pub const ARKUI_COLOR_MODE_SYSTEM: ArkUI_ColorMode = ArkUI_ColorMode(0);
}
impl ArkUI_ColorMode {
    /// Light color mode.
    pub const ARKUI_COLOR_MODE_LIGHT: ArkUI_ColorMode = ArkUI_ColorMode(1);
}
impl ArkUI_ColorMode {
    /// Dark color mode.
    pub const ARKUI_COLOR_MODE_DARK: ArkUI_ColorMode = ArkUI_ColorMode(2);
}
#[repr(transparent)]
/** @brief Enumerates the color modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ColorMode(pub ::core::ffi::c_uint);
impl ArkUI_SystemColorMode {
    /// Light color mode.
    pub const ARKUI_SYSTEM_COLOR_MODE_LIGHT: ArkUI_SystemColorMode = ArkUI_SystemColorMode(0);
}
impl ArkUI_SystemColorMode {
    /// Dark color mode.
    pub const ARKUI_SYSTEM_COLOR_MODE_DARK: ArkUI_SystemColorMode = ArkUI_SystemColorMode(1);
}
#[repr(transparent)]
/** @brief Enumerates the system color modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SystemColorMode(pub ::core::ffi::c_uint);
impl ArkUI_BlurStyle {
    /// Thin material.
    pub const ARKUI_BLUR_STYLE_THIN: ArkUI_BlurStyle = ArkUI_BlurStyle(0);
}
impl ArkUI_BlurStyle {
    /// Regular material.
    pub const ARKUI_BLUR_STYLE_REGULAR: ArkUI_BlurStyle = ArkUI_BlurStyle(1);
}
impl ArkUI_BlurStyle {
    /// Thick material.
    pub const ARKUI_BLUR_STYLE_THICK: ArkUI_BlurStyle = ArkUI_BlurStyle(2);
}
impl ArkUI_BlurStyle {
    /// Material that creates the minimum depth of field effect.
    pub const ARKUI_BLUR_STYLE_BACKGROUND_THIN: ArkUI_BlurStyle = ArkUI_BlurStyle(3);
}
impl ArkUI_BlurStyle {
    /// Material that creates a medium shallow depth of field effect.
    pub const ARKUI_BLUR_STYLE_BACKGROUND_REGULAR: ArkUI_BlurStyle = ArkUI_BlurStyle(4);
}
impl ArkUI_BlurStyle {
    /// Material that creates a high shallow depth of field effect.
    pub const ARKUI_BLUR_STYLE_BACKGROUND_THICK: ArkUI_BlurStyle = ArkUI_BlurStyle(5);
}
impl ArkUI_BlurStyle {
    /// Material that creates the maximum depth of field effect.
    pub const ARKUI_BLUR_STYLE_BACKGROUND_ULTRA_THICK: ArkUI_BlurStyle = ArkUI_BlurStyle(6);
}
impl ArkUI_BlurStyle {
    /// No blur.
    pub const ARKUI_BLUR_STYLE_NONE: ArkUI_BlurStyle = ArkUI_BlurStyle(7);
}
impl ArkUI_BlurStyle {
    /// Component ultra-thin material.
    pub const ARKUI_BLUR_STYLE_COMPONENT_ULTRA_THIN: ArkUI_BlurStyle = ArkUI_BlurStyle(8);
}
impl ArkUI_BlurStyle {
    /// Component thin material.
    pub const ARKUI_BLUR_STYLE_COMPONENT_THIN: ArkUI_BlurStyle = ArkUI_BlurStyle(9);
}
impl ArkUI_BlurStyle {
    /// Component regular material.
    pub const ARKUI_BLUR_STYLE_COMPONENT_REGULAR: ArkUI_BlurStyle = ArkUI_BlurStyle(10);
}
impl ArkUI_BlurStyle {
    /// Component thick material.
    pub const ARKUI_BLUR_STYLE_COMPONENT_THICK: ArkUI_BlurStyle = ArkUI_BlurStyle(11);
}
impl ArkUI_BlurStyle {
    /// Component ultra-thick material.
    pub const ARKUI_BLUR_STYLE_COMPONENT_ULTRA_THICK: ArkUI_BlurStyle = ArkUI_BlurStyle(12);
}
#[repr(transparent)]
/** @brief Enumerates the blur styles.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_BlurStyle(pub ::core::ffi::c_uint);
impl ArkUI_VerticalAlignment {
    /// Top aligned.
    pub const ARKUI_VERTICAL_ALIGNMENT_TOP: ArkUI_VerticalAlignment = ArkUI_VerticalAlignment(0);
}
impl ArkUI_VerticalAlignment {
    /// Center aligned. This is the default alignment mode.
    pub const ARKUI_VERTICAL_ALIGNMENT_CENTER: ArkUI_VerticalAlignment = ArkUI_VerticalAlignment(1);
}
impl ArkUI_VerticalAlignment {
    /// Bottom aligned.
    pub const ARKUI_VERTICAL_ALIGNMENT_BOTTOM: ArkUI_VerticalAlignment = ArkUI_VerticalAlignment(2);
}
#[repr(transparent)]
/** @brief Enumerates the vertical alignment modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_VerticalAlignment(pub ::core::ffi::c_uint);
impl ArkUI_HorizontalAlignment {
    /// Aligned with the start edge in the same direction as the language in use.
    pub const ARKUI_HORIZONTAL_ALIGNMENT_START: ArkUI_HorizontalAlignment =
        ArkUI_HorizontalAlignment(0);
}
impl ArkUI_HorizontalAlignment {
    /// Center aligned. This is the default alignment mode.
    pub const ARKUI_HORIZONTAL_ALIGNMENT_CENTER: ArkUI_HorizontalAlignment =
        ArkUI_HorizontalAlignment(1);
}
impl ArkUI_HorizontalAlignment {
    /// Aligned with the end edge in the same direction as the language in use.
    pub const ARKUI_HORIZONTAL_ALIGNMENT_END: ArkUI_HorizontalAlignment =
        ArkUI_HorizontalAlignment(2);
}
#[repr(transparent)]
/** @brief Enumerates the alignment mode in the horizontal direction.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_HorizontalAlignment(pub ::core::ffi::c_uint);
impl ArkUI_TextOverflow {
    /// Extra-long text is not clipped.
    pub const ARKUI_TEXT_OVERFLOW_NONE: ArkUI_TextOverflow = ArkUI_TextOverflow(0);
}
impl ArkUI_TextOverflow {
    /// Extra-long text is clipped.
    pub const ARKUI_TEXT_OVERFLOW_CLIP: ArkUI_TextOverflow = ArkUI_TextOverflow(1);
}
impl ArkUI_TextOverflow {
    /// An ellipsis (...) is used to represent text overflow.
    pub const ARKUI_TEXT_OVERFLOW_ELLIPSIS: ArkUI_TextOverflow = ArkUI_TextOverflow(2);
}
impl ArkUI_TextOverflow {
    /// Text continuously scrolls when text overflow occurs.
    pub const ARKUI_TEXT_OVERFLOW_MARQUEE: ArkUI_TextOverflow = ArkUI_TextOverflow(3);
}
#[repr(transparent)]
/** @brief Enumerates the display modes when the text is too long.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextOverflow(pub ::core::ffi::c_uint);
impl ArkUI_ImageSpanAlignment {
    /// The image is bottom aligned with the text baseline.
    pub const ARKUI_IMAGE_SPAN_ALIGNMENT_BASELINE: ArkUI_ImageSpanAlignment =
        ArkUI_ImageSpanAlignment(0);
}
impl ArkUI_ImageSpanAlignment {
    /// The image is bottom aligned with the text.
    pub const ARKUI_IMAGE_SPAN_ALIGNMENT_BOTTOM: ArkUI_ImageSpanAlignment =
        ArkUI_ImageSpanAlignment(1);
}
impl ArkUI_ImageSpanAlignment {
    /// The image is centered aligned with the text.
    pub const ARKUI_IMAGE_SPAN_ALIGNMENT_CENTER: ArkUI_ImageSpanAlignment =
        ArkUI_ImageSpanAlignment(2);
}
impl ArkUI_ImageSpanAlignment {
    /// The image is top aligned with the text.
    pub const ARKUI_IMAGE_SPAN_ALIGNMENT_TOP: ArkUI_ImageSpanAlignment =
        ArkUI_ImageSpanAlignment(3);
}
#[repr(transparent)]
/** @brief Enumerates the alignment mode of the image with the text.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ImageSpanAlignment(pub ::core::ffi::c_uint);
impl ArkUI_ObjectFit {
    /** The image is scaled with its aspect ratio retained for the content to be completely displayed within the
    display boundaries.*/
    pub const ARKUI_OBJECT_FIT_CONTAIN: ArkUI_ObjectFit = ArkUI_ObjectFit(0);
}
impl ArkUI_ObjectFit {
    /** The image is scaled with its aspect ratio retained for both sides to be greater than or equal to the
    display boundaries.*/
    pub const ARKUI_OBJECT_FIT_COVER: ArkUI_ObjectFit = ArkUI_ObjectFit(1);
}
impl ArkUI_ObjectFit {
    /// The image is scaled automatically to fit the display area.
    pub const ARKUI_OBJECT_FIT_AUTO: ArkUI_ObjectFit = ArkUI_ObjectFit(2);
}
impl ArkUI_ObjectFit {
    /// The image is scaled to fill the display area, and its aspect ratio is not retained.
    pub const ARKUI_OBJECT_FIT_FILL: ArkUI_ObjectFit = ArkUI_ObjectFit(3);
}
impl ArkUI_ObjectFit {
    /** The image content is displayed with its aspect ratio retained. The size is smaller than or equal to the
    original size.*/
    pub const ARKUI_OBJECT_FIT_SCALE_DOWN: ArkUI_ObjectFit = ArkUI_ObjectFit(4);
}
impl ArkUI_ObjectFit {
    /// The original size is retained.
    pub const ARKUI_OBJECT_FIT_NONE: ArkUI_ObjectFit = ArkUI_ObjectFit(5);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is aligned with the start edge of the top of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP_START: ArkUI_ObjectFit = ArkUI_ObjectFit(6);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is horizontally centered at the top of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP: ArkUI_ObjectFit = ArkUI_ObjectFit(7);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is aligned with the end edge at the top of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_TOP_END: ArkUI_ObjectFit = ArkUI_ObjectFit(8);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is vertically centered on the start edge of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_START: ArkUI_ObjectFit = ArkUI_ObjectFit(9);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is horizontally and vertically centered in the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_CENTER: ArkUI_ObjectFit = ArkUI_ObjectFit(10);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is vertically centered on the end edge of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_END: ArkUI_ObjectFit = ArkUI_ObjectFit(11);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is aligned with the start edge at the bottom of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM_START: ArkUI_ObjectFit = ArkUI_ObjectFit(12);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is horizontally centered at the bottom of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM: ArkUI_ObjectFit = ArkUI_ObjectFit(13);
}
impl ArkUI_ObjectFit {
    /// Not resized, the image is aligned with the end edge at the bottom of the container.
    pub const ARKUI_OBJECT_FIT_NONE_AND_ALIGN_BOTTOM_END: ArkUI_ObjectFit = ArkUI_ObjectFit(14);
}
#[repr(transparent)]
/** @brief Defines how the image is resized to fit its container.
ImageSpanAlignment
 @since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ObjectFit(pub ::core::ffi::c_uint);
impl ArkUI_ImageInterpolation {
    /// No image interpolation.
    pub const ARKUI_IMAGE_INTERPOLATION_NONE: ArkUI_ImageInterpolation =
        ArkUI_ImageInterpolation(0);
}
impl ArkUI_ImageInterpolation {
    /// Low quality interpolation.
    pub const ARKUI_IMAGE_INTERPOLATION_LOW: ArkUI_ImageInterpolation = ArkUI_ImageInterpolation(1);
}
impl ArkUI_ImageInterpolation {
    /// Medium quality interpolation.
    pub const ARKUI_IMAGE_INTERPOLATION_MEDIUM: ArkUI_ImageInterpolation =
        ArkUI_ImageInterpolation(2);
}
impl ArkUI_ImageInterpolation {
    /// High quality interpolation. This mode produces scaled images of the highest possible quality.
    pub const ARKUI_IMAGE_INTERPOLATION_HIGH: ArkUI_ImageInterpolation =
        ArkUI_ImageInterpolation(3);
}
#[repr(transparent)]
/** @brief Enumerates the image interpolation effect.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ImageInterpolation(pub ::core::ffi::c_uint);
impl ArkUI_BlendMode {
    /// The top image is superimposed on the bottom image without any blending.
    pub const ARKUI_BLEND_MODE_NONE: ArkUI_BlendMode = ArkUI_BlendMode(0);
}
impl ArkUI_BlendMode {
    /// The target pixels covered by the source pixels are erased by being turned to completely transparent.
    pub const ARKUI_BLEND_MODE_CLEAR: ArkUI_BlendMode = ArkUI_BlendMode(1);
}
impl ArkUI_BlendMode {
    /// r = s: Only the source pixels are displayed.
    pub const ARKUI_BLEND_MODE_SRC: ArkUI_BlendMode = ArkUI_BlendMode(2);
}
impl ArkUI_BlendMode {
    /// r = d: Only the target pixels are displayed.
    pub const ARKUI_BLEND_MODE_DST: ArkUI_BlendMode = ArkUI_BlendMode(3);
}
impl ArkUI_BlendMode {
    /// r = s + (1 - sa) * d: The source pixels are blended based on opacity and cover the target pixels.
    pub const ARKUI_BLEND_MODE_SRC_OVER: ArkUI_BlendMode = ArkUI_BlendMode(4);
}
impl ArkUI_BlendMode {
    /// r = d + (1 - da) * s: The target pixels are blended based on opacity and cover on the source pixels.
    pub const ARKUI_BLEND_MODE_DST_OVER: ArkUI_BlendMode = ArkUI_BlendMode(5);
}
impl ArkUI_BlendMode {
    /// r = s * da: Only the part of the source pixels that overlap with the target pixels is displayed.
    pub const ARKUI_BLEND_MODE_SRC_IN: ArkUI_BlendMode = ArkUI_BlendMode(6);
}
impl ArkUI_BlendMode {
    /// r = d * sa: Only the part of the target pixels that overlap with the source pixels is displayed.
    pub const ARKUI_BLEND_MODE_DST_IN: ArkUI_BlendMode = ArkUI_BlendMode(7);
}
impl ArkUI_BlendMode {
    /// r = s * (1 - da): Only the part of the source pixels that do not overlap with the target pixels is displayed.
    pub const ARKUI_BLEND_MODE_SRC_OUT: ArkUI_BlendMode = ArkUI_BlendMode(8);
}
impl ArkUI_BlendMode {
    /// r = d * (1 - sa): Only the part of the target pixels that do not overlap with the source pixels is displayed.
    pub const ARKUI_BLEND_MODE_DST_OUT: ArkUI_BlendMode = ArkUI_BlendMode(9);
}
impl ArkUI_BlendMode {
    /** r = s * da + d * (1 - sa): The part of the source pixels that overlap with the target pixels is displayed and
    the part of the target pixels that do not overlap with the source pixels are displayed.*/
    pub const ARKUI_BLEND_MODE_SRC_ATOP: ArkUI_BlendMode = ArkUI_BlendMode(10);
}
impl ArkUI_BlendMode {
    /** r = d * sa + s * (1 - da): The part of the target pixels that overlap with the source pixels and the part of
    the source pixels that do not overlap with the target pixels are displayed.*/
    pub const ARKUI_BLEND_MODE_DST_ATOP: ArkUI_BlendMode = ArkUI_BlendMode(11);
}
impl ArkUI_BlendMode {
    /** r = s * (1 - da) + d * (1 - sa): Only the non-overlapping part between the source pixels and the target pixels
    is displayed.*/
    pub const ARKUI_BLEND_MODE_XOR: ArkUI_BlendMode = ArkUI_BlendMode(12);
}
impl ArkUI_BlendMode {
    /// r = min(s + d, 1): New pixels resulting from adding the source pixels to the target pixels are displayed.
    pub const ARKUI_BLEND_MODE_PLUS: ArkUI_BlendMode = ArkUI_BlendMode(13);
}
impl ArkUI_BlendMode {
    /// r = s * d: New pixels resulting from multiplying the source pixels with the target pixels are displayed.
    pub const ARKUI_BLEND_MODE_MODULATE: ArkUI_BlendMode = ArkUI_BlendMode(14);
}
impl ArkUI_BlendMode {
    /** r = s + d - s * d: Pixels are blended by adding the source pixels to the target pixels and subtracting the
    product of their multiplication.*/
    pub const ARKUI_BLEND_MODE_SCREEN: ArkUI_BlendMode = ArkUI_BlendMode(15);
}
impl ArkUI_BlendMode {
    /// The MULTIPLY or SCREEN mode is used based on the target pixels.
    pub const ARKUI_BLEND_MODE_OVERLAY: ArkUI_BlendMode = ArkUI_BlendMode(16);
}
impl ArkUI_BlendMode {
    /// rc = s + d - max(s * da, d * sa), ra = kSrcOver: When two colors overlap, whichever is darker is used.
    pub const ARKUI_BLEND_MODE_DARKEN: ArkUI_BlendMode = ArkUI_BlendMode(17);
}
impl ArkUI_BlendMode {
    /** rc = s + d - min(s * da, d * sa), ra =
    kSrcOver: The final pixels are composed of the lightest values of pixels.*/
    pub const ARKUI_BLEND_MODE_LIGHTEN: ArkUI_BlendMode = ArkUI_BlendMode(18);
}
impl ArkUI_BlendMode {
    /// The colors of the target pixels are lightened to reflect the source pixels.
    pub const ARKUI_BLEND_MODE_COLOR_DODGE: ArkUI_BlendMode = ArkUI_BlendMode(19);
}
impl ArkUI_BlendMode {
    /// The colors of the target pixels are darkened to reflect the source pixels.
    pub const ARKUI_BLEND_MODE_COLOR_BURN: ArkUI_BlendMode = ArkUI_BlendMode(20);
}
impl ArkUI_BlendMode {
    /// The MULTIPLY or SCREEN mode is used, depending on the source pixels.
    pub const ARKUI_BLEND_MODE_HARD_LIGHT: ArkUI_BlendMode = ArkUI_BlendMode(21);
}
impl ArkUI_BlendMode {
    /// The LIGHTEN or DARKEN mode is used, depending on the source pixels.
    pub const ARKUI_BLEND_MODE_SOFT_LIGHT: ArkUI_BlendMode = ArkUI_BlendMode(22);
}
impl ArkUI_BlendMode {
    /** rc = s + d - 2 * (min(s * da, d * sa)), ra =
    kSrcOver: The final pixel is the result of subtracting the darker of the two pixels (source and target) from
    the lighter one.*/
    pub const ARKUI_BLEND_MODE_DIFFERENCE: ArkUI_BlendMode = ArkUI_BlendMode(23);
}
impl ArkUI_BlendMode {
    /// rc = s + d - two(s * d), ra = kSrcOver: The final pixel is similar to <b>DIFFERENCE</b>, but with less contrast.
    pub const ARKUI_BLEND_MODE_EXCLUSION: ArkUI_BlendMode = ArkUI_BlendMode(24);
}
impl ArkUI_BlendMode {
    /** r = s * (1 - da) + d * (1 - sa) + s * d: The final pixel is the result of multiplying the source pixel
    by the target pixel.*/
    pub const ARKUI_BLEND_MODE_MULTIPLY: ArkUI_BlendMode = ArkUI_BlendMode(25);
}
impl ArkUI_BlendMode {
    /** The resultant image is created with the luminance and saturation of the source image and the hue of the target
    image.*/
    pub const ARKUI_BLEND_MODE_HUE: ArkUI_BlendMode = ArkUI_BlendMode(26);
}
impl ArkUI_BlendMode {
    /** The resultant image is created with the luminance and hue of the target image and the saturation of the source
    image.*/
    pub const ARKUI_BLEND_MODE_SATURATION: ArkUI_BlendMode = ArkUI_BlendMode(27);
}
impl ArkUI_BlendMode {
    /** The resultant image is created with the saturation and hue of the source image and the luminance of the target
    image.*/
    pub const ARKUI_BLEND_MODE_COLOR: ArkUI_BlendMode = ArkUI_BlendMode(28);
}
impl ArkUI_BlendMode {
    /** The resultant image is created with the saturation and hue of the target image and the luminance of the source
    image.*/
    pub const ARKUI_BLEND_MODE_LUMINOSITY: ArkUI_BlendMode = ArkUI_BlendMode(29);
}
#[repr(transparent)]
/** @brief Enumerates the blend modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_BlendMode(pub ::core::ffi::c_uint);
impl ArkUI_Direction {
    /// Components are arranged from left to right.
    pub const ARKUI_DIRECTION_LTR: ArkUI_Direction = ArkUI_Direction(0);
}
impl ArkUI_Direction {
    /// Components are arranged from right to left.
    pub const ARKUI_DIRECTION_RTL: ArkUI_Direction = ArkUI_Direction(1);
}
impl ArkUI_Direction {
    /// The default layout direction is used.
    pub const ARKUI_DIRECTION_AUTO: ArkUI_Direction = ArkUI_Direction(3);
}
#[repr(transparent)]
/** @brief Enumerates the modes in which components are laid out along the main axis of the container.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_Direction(pub ::core::ffi::c_uint);
impl ArkUI_ItemAlignment {
    /// The default configuration in the container is used.
    pub const ARKUI_ITEM_ALIGNMENT_AUTO: ArkUI_ItemAlignment = ArkUI_ItemAlignment(0);
}
impl ArkUI_ItemAlignment {
    /// The items in the container are aligned with the cross-start edge.
    pub const ARKUI_ITEM_ALIGNMENT_START: ArkUI_ItemAlignment = ArkUI_ItemAlignment(1);
}
impl ArkUI_ItemAlignment {
    /// The items in the container are centered along the cross axis.
    pub const ARKUI_ITEM_ALIGNMENT_CENTER: ArkUI_ItemAlignment = ArkUI_ItemAlignment(2);
}
impl ArkUI_ItemAlignment {
    /// The items in the container are aligned with the cross-end edge.
    pub const ARKUI_ITEM_ALIGNMENT_END: ArkUI_ItemAlignment = ArkUI_ItemAlignment(3);
}
impl ArkUI_ItemAlignment {
    /// The items in the container are stretched and padded along the cross axis.
    pub const ARKUI_ITEM_ALIGNMENT_STRETCH: ArkUI_ItemAlignment = ArkUI_ItemAlignment(4);
}
impl ArkUI_ItemAlignment {
    /** The items in the container are aligned in such a manner that their text baselines are aligned along the
    cross axis.*/
    pub const ARKUI_ITEM_ALIGNMENT_BASELINE: ArkUI_ItemAlignment = ArkUI_ItemAlignment(5);
}
#[repr(transparent)]
/** @brief Enumerates the modes in which components are laid out along the cross axis of the container.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ItemAlignment(pub ::core::ffi::c_uint);
impl ArkUI_ColorStrategy {
    /// The foreground colors are the inverse of the component background colors.
    pub const ARKUI_COLOR_STRATEGY_INVERT: ArkUI_ColorStrategy = ArkUI_ColorStrategy(0);
}
impl ArkUI_ColorStrategy {
    /// The shadow colors of the component are the average color obtained from the component background shadow area.
    pub const ARKUI_COLOR_STRATEGY_AVERAGE: ArkUI_ColorStrategy = ArkUI_ColorStrategy(1);
}
impl ArkUI_ColorStrategy {
    /// The shadow colors of the component are the primary color obtained from the component background shadow area.
    pub const ARKUI_COLOR_STRATEGY_PRIMARY: ArkUI_ColorStrategy = ArkUI_ColorStrategy(2);
}
#[repr(transparent)]
/** @brief Enumerates the foreground colors.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ColorStrategy(pub ::core::ffi::c_uint);
impl ArkUI_FlexAlignment {
    /// The child components are aligned with the start edge of the main axis.
    pub const ARKUI_FLEX_ALIGNMENT_START: ArkUI_FlexAlignment = ArkUI_FlexAlignment(1);
}
impl ArkUI_FlexAlignment {
    /// The child components are aligned in the center of the main axis.
    pub const ARKUI_FLEX_ALIGNMENT_CENTER: ArkUI_FlexAlignment = ArkUI_FlexAlignment(2);
}
impl ArkUI_FlexAlignment {
    /// The child components are aligned with the end edge of the main axis.
    pub const ARKUI_FLEX_ALIGNMENT_END: ArkUI_FlexAlignment = ArkUI_FlexAlignment(3);
}
impl ArkUI_FlexAlignment {
    /** The child components are evenly distributed along the main axis. The space between any two adjacent components
    is the same. The first component is aligned with the main-start, and the last component is aligned with
    the main-end.*/
    pub const ARKUI_FLEX_ALIGNMENT_SPACE_BETWEEN: ArkUI_FlexAlignment = ArkUI_FlexAlignment(6);
}
impl ArkUI_FlexAlignment {
    /** The child components are evenly distributed along the main axis. The space between any two adjacent components
    is the same. The space between the first component and main-start, and that between the last component and
    cross-main are both half the size of the space between two adjacent components.*/
    pub const ARKUI_FLEX_ALIGNMENT_SPACE_AROUND: ArkUI_FlexAlignment = ArkUI_FlexAlignment(7);
}
impl ArkUI_FlexAlignment {
    /** The child components are evenly distributed along the main axis. The space between the first component
    and main-start, the space between the last component and main-end, and the space between any two adjacent
    components are the same.*/
    pub const ARKUI_FLEX_ALIGNMENT_SPACE_EVENLY: ArkUI_FlexAlignment = ArkUI_FlexAlignment(8);
}
#[repr(transparent)]
/** @brief Enumerates the vertical alignment modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_FlexAlignment(pub ::core::ffi::c_uint);
impl ArkUI_FlexDirection {
    /// The child components are arranged in the same direction as the main axis runs along the rows.
    pub const ARKUI_FLEX_DIRECTION_ROW: ArkUI_FlexDirection = ArkUI_FlexDirection(0);
}
impl ArkUI_FlexDirection {
    /// The child components are arranged in the same direction as the main axis runs down the columns.
    pub const ARKUI_FLEX_DIRECTION_COLUMN: ArkUI_FlexDirection = ArkUI_FlexDirection(1);
}
impl ArkUI_FlexDirection {
    /// The child components are arranged opposite to the <b>ROW</b> direction.
    pub const ARKUI_FLEX_DIRECTION_ROW_REVERSE: ArkUI_FlexDirection = ArkUI_FlexDirection(2);
}
impl ArkUI_FlexDirection {
    /// The child components are arranged opposite to the <b>COLUMN</b> direction.
    pub const ARKUI_FLEX_DIRECTION_COLUMN_REVERSE: ArkUI_FlexDirection = ArkUI_FlexDirection(3);
}
#[repr(transparent)]
/** @brief Enumerates the directions of the main axis in the flex container.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_FlexDirection(pub ::core::ffi::c_uint);
impl ArkUI_FlexWrap {
    /// The child components in the flex container are arranged in a single line, and they cannot overflow.
    pub const ARKUI_FLEX_WRAP_NO_WRAP: ArkUI_FlexWrap = ArkUI_FlexWrap(0);
}
impl ArkUI_FlexWrap {
    /// The child components in the flex container are arranged in multiple lines, and they may overflow.
    pub const ARKUI_FLEX_WRAP_WRAP: ArkUI_FlexWrap = ArkUI_FlexWrap(1);
}
impl ArkUI_FlexWrap {
    /// The child components in the flex container are reversely arranged in multiple lines, and they may overflow.
    pub const ARKUI_FLEX_WRAP_WRAP_REVERSE: ArkUI_FlexWrap = ArkUI_FlexWrap(2);
}
#[repr(transparent)]
/** @brief Defines whether the flex container has a single line or multiple lines.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_FlexWrap(pub ::core::ffi::c_uint);
impl ArkUI_Visibility {
    /// The component is visible.
    pub const ARKUI_VISIBILITY_VISIBLE: ArkUI_Visibility = ArkUI_Visibility(0);
}
impl ArkUI_Visibility {
    /// The component is hidden, and a placeholder is used for it in the layout.
    pub const ARKUI_VISIBILITY_HIDDEN: ArkUI_Visibility = ArkUI_Visibility(1);
}
impl ArkUI_Visibility {
    /// The component is hidden. It is not involved in the layout, and no placeholder is used for it.
    pub const ARKUI_VISIBILITY_NONE: ArkUI_Visibility = ArkUI_Visibility(2);
}
#[repr(transparent)]
/** @brief Enumerates the visibility values.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_Visibility(pub ::core::ffi::c_uint);
impl ArkUI_CalendarAlignment {
    /// Left aligned.
    pub const ARKUI_CALENDAR_ALIGNMENT_START: ArkUI_CalendarAlignment = ArkUI_CalendarAlignment(0);
}
impl ArkUI_CalendarAlignment {
    /// Center aligned.
    pub const ARKUI_CALENDAR_ALIGNMENT_CENTER: ArkUI_CalendarAlignment = ArkUI_CalendarAlignment(1);
}
impl ArkUI_CalendarAlignment {
    /// Right aligned.
    pub const ARKUI_CALENDAR_ALIGNMENT_END: ArkUI_CalendarAlignment = ArkUI_CalendarAlignment(2);
}
#[repr(transparent)]
/** @brief Enumerates the alignment modes between the calendar picker and the entry component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_CalendarAlignment(pub ::core::ffi::c_uint);
impl ArkUI_MaskType {
    /// Rectangle.
    pub const ARKUI_MASK_TYPE_RECTANGLE: ArkUI_MaskType = ArkUI_MaskType(0);
}
impl ArkUI_MaskType {
    /// Circle.
    pub const ARKUI_MASK_TYPE_CIRCLE: ArkUI_MaskType = ArkUI_MaskType(1);
}
impl ArkUI_MaskType {
    /// Ellipse.
    pub const ARKUI_MASK_TYPE_ELLIPSE: ArkUI_MaskType = ArkUI_MaskType(2);
}
impl ArkUI_MaskType {
    /// Path.
    pub const ARKUI_MASK_TYPE_PATH: ArkUI_MaskType = ArkUI_MaskType(3);
}
impl ArkUI_MaskType {
    /// Progress indicator.
    pub const ARKUI_MASK_TYPE_PROGRESS: ArkUI_MaskType = ArkUI_MaskType(4);
}
#[repr(transparent)]
/** @brief Enumerates the mask types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_MaskType(pub ::core::ffi::c_uint);
impl ArkUI_ClipType {
    /// Rectangle.
    pub const ARKUI_CLIP_TYPE_RECTANGLE: ArkUI_ClipType = ArkUI_ClipType(0);
}
impl ArkUI_ClipType {
    /// Circle.
    pub const ARKUI_CLIP_TYPE_CIRCLE: ArkUI_ClipType = ArkUI_ClipType(1);
}
impl ArkUI_ClipType {
    /// Ellipse.
    pub const ARKUI_CLIP_TYPE_ELLIPSE: ArkUI_ClipType = ArkUI_ClipType(2);
}
impl ArkUI_ClipType {
    /// Path.
    pub const ARKUI_CLIP_TYPE_PATH: ArkUI_ClipType = ArkUI_ClipType(3);
}
#[repr(transparent)]
/** @brief Enumerates the clipping region types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ClipType(pub ::core::ffi::c_uint);
/** @brief Defines the gradient color stop structure.

@since 12*/
#[repr(C)]
pub struct ArkUI_ColorStop {
    /// Color array.
    pub colors: *const u32,
    /// Position array.
    pub stops: *mut f32,
    /// Length array.
    pub size: ::core::ffi::c_int,
}
impl ArkUI_ShapeType {
    /// Rectangle.
    pub const ARKUI_SHAPE_TYPE_RECTANGLE: ArkUI_ShapeType = ArkUI_ShapeType(0);
}
impl ArkUI_ShapeType {
    /// Circle.
    pub const ARKUI_SHAPE_TYPE_CIRCLE: ArkUI_ShapeType = ArkUI_ShapeType(1);
}
impl ArkUI_ShapeType {
    /// Ellipse.
    pub const ARKUI_SHAPE_TYPE_ELLIPSE: ArkUI_ShapeType = ArkUI_ShapeType(2);
}
impl ArkUI_ShapeType {
    /// Path.
    pub const ARKUI_SHAPE_TYPE_PATH: ArkUI_ShapeType = ArkUI_ShapeType(3);
}
#[repr(transparent)]
/** @brief Enumerates the custom shapes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ShapeType(pub ::core::ffi::c_uint);
impl ArkUI_LinearGradientDirection {
    /// From right to left.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(0);
}
impl ArkUI_LinearGradientDirection {
    /// From bottom to top.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_TOP: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(1);
}
impl ArkUI_LinearGradientDirection {
    /// From left to right.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(2);
}
impl ArkUI_LinearGradientDirection {
    /// From top to bottom.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_BOTTOM: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(3);
}
impl ArkUI_LinearGradientDirection {
    /// From lower right to upper left.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT_TOP: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(4);
}
impl ArkUI_LinearGradientDirection {
    /// From upper right to lower left.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_LEFT_BOTTOM: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(5);
}
impl ArkUI_LinearGradientDirection {
    /// From lower left to upper right.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT_TOP: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(6);
}
impl ArkUI_LinearGradientDirection {
    /// From upper left to lower right.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_RIGHT_BOTTOM: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(7);
}
impl ArkUI_LinearGradientDirection {
    /// No gradient.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_NONE: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(8);
}
impl ArkUI_LinearGradientDirection {
    /// Custom direction.
    pub const ARKUI_LINEAR_GRADIENT_DIRECTION_CUSTOM: ArkUI_LinearGradientDirection =
        ArkUI_LinearGradientDirection(9);
}
#[repr(transparent)]
/** @brief Enumerates the gradient directions.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_LinearGradientDirection(pub ::core::ffi::c_uint);
impl ArkUI_WordBreak {
    /** Word breaks can occur between any two characters for Chinese, Japanese, and Korean (CJK) text, but can occur
    only at a space character for non-CJK text (such as English).*/
    pub const ARKUI_WORD_BREAK_NORMAL: ArkUI_WordBreak = ArkUI_WordBreak(0);
}
impl ArkUI_WordBreak {
    /** Word breaks can occur between any two characters for non-CJK text. CJK text behavior is the same as for
    <b>NORMAL</b>.*/
    pub const ARKUI_WORD_BREAK_BREAK_ALL: ArkUI_WordBreak = ArkUI_WordBreak(1);
}
impl ArkUI_WordBreak {
    /** This option has the same effect as <b>BREAK_ALL</b> for non-CJK text, except that if it preferentially wraps
      lines at appropriate characters (for example, spaces) whenever possible.
    CJK text behavior is the same as for <b>NORMAL</b>.*/
    pub const ARKUI_WORD_BREAK_BREAK_WORD: ArkUI_WordBreak = ArkUI_WordBreak(2);
}
#[repr(transparent)]
/** @brief Enumerates the word break rules.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_WordBreak(pub ::core::ffi::c_uint);
impl ArkUI_EllipsisMode {
    /// An ellipsis is used at the start of the line of text.
    pub const ARKUI_ELLIPSIS_MODE_START: ArkUI_EllipsisMode = ArkUI_EllipsisMode(0);
}
impl ArkUI_EllipsisMode {
    /// An ellipsis is used at the center of the line of text.
    pub const ARKUI_ELLIPSIS_MODE_CENTER: ArkUI_EllipsisMode = ArkUI_EllipsisMode(1);
}
impl ArkUI_EllipsisMode {
    /// An ellipsis is used at the end of the line of text.
    pub const ARKUI_ELLIPSIS_MODE_END: ArkUI_EllipsisMode = ArkUI_EllipsisMode(2);
}
#[repr(transparent)]
/** @brief Enumerates the ellipsis positions.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_EllipsisMode(pub ::core::ffi::c_uint);
impl ArkUI_ImageRenderMode {
    /// Render image pixels as they are in the original source image.
    pub const ARKUI_IMAGE_RENDER_MODE_ORIGINAL: ArkUI_ImageRenderMode = ArkUI_ImageRenderMode(0);
}
impl ArkUI_ImageRenderMode {
    /// Render image pixels to create a monochrome template image.
    pub const ARKUI_IMAGE_RENDER_MODE_TEMPLATE: ArkUI_ImageRenderMode = ArkUI_ImageRenderMode(1);
}
#[repr(transparent)]
/** @brief Enumerates the image rendering modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ImageRenderMode(pub ::core::ffi::c_uint);
impl ArkUI_TransitionEdge {
    /// Top edge of the window.
    pub const ARKUI_TRANSITION_EDGE_TOP: ArkUI_TransitionEdge = ArkUI_TransitionEdge(0);
}
impl ArkUI_TransitionEdge {
    /// Bottom edge of the window.
    pub const ARKUI_TRANSITION_EDGE_BOTTOM: ArkUI_TransitionEdge = ArkUI_TransitionEdge(1);
}
impl ArkUI_TransitionEdge {
    /// Left edge of the window.
    pub const ARKUI_TRANSITION_EDGE_START: ArkUI_TransitionEdge = ArkUI_TransitionEdge(2);
}
impl ArkUI_TransitionEdge {
    /// Right edge of the window.
    pub const ARKUI_TRANSITION_EDGE_END: ArkUI_TransitionEdge = ArkUI_TransitionEdge(3);
}
#[repr(transparent)]
/** @brief Enumerates the slide-in and slide-out positions of the component from the screen edge during transition.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TransitionEdge(pub ::core::ffi::c_uint);
impl ArkUI_BlendApplyType {
    /// The content of the view is blended in sequence on the target image.
    pub const BLEND_APPLY_TYPE_FAST: ArkUI_BlendApplyType = ArkUI_BlendApplyType(0);
}
impl ArkUI_BlendApplyType {
    #[doc = " The content of the component and its child components are drawn on the offscreen canvas, and then blended with\n/*  the existing content on the canvas."]
    pub const BLEND_APPLY_TYPE_OFFSCREEN: ArkUI_BlendApplyType = ArkUI_BlendApplyType(1);
}
#[repr(transparent)]
/** @brief Defines how the specified blend mode is applied.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_BlendApplyType(pub ::core::ffi::c_uint);
/** @brief Defines a mask area.

@since 12*/
#[repr(C)]
pub struct ArkUI_Rect {
    /// X coordinate of the mask area.
    pub x: f32,
    /// Y coordinate of the mask area.
    pub y: f32,
    /// Width of the mask area.
    pub width: f32,
    /// Height of the mask area.
    pub height: f32,
}
/** @brief Describes the width and height of a component.

@since 12*/
#[repr(C)]
pub struct ArkUI_IntSize {
    /// Width, in px.
    pub width: i32,
    /// Height, in px.
    pub height: i32,
}
/** @brief Describes the position of a component.

@since 12*/
#[repr(C)]
pub struct ArkUI_IntOffset {
    /// Horizontal coordinate, in px.
    pub x: i32,
    /// Vertical coordinate, in px.
    pub y: i32,
}
impl ArkUI_FinishCallbackType {
    /// The callback is invoked when the entire animation is removed once it has finished.
    pub const ARKUI_FINISH_CALLBACK_REMOVED: ArkUI_FinishCallbackType = ArkUI_FinishCallbackType(0);
}
impl ArkUI_FinishCallbackType {
    /** The callback is invoked when the animation logically enters the falling state, though it may still be in its
    long tail state.*/
    pub const ARKUI_FINISH_CALLBACK_LOGICALLY: ArkUI_FinishCallbackType =
        ArkUI_FinishCallbackType(1);
}
#[repr(transparent)]
/** @brief Enumerates the animation onFinish callback types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_FinishCallbackType(pub ::core::ffi::c_uint);
impl ArkUI_ListItemAlignment {
    /// The list items are packed toward the start edge of the list container along the cross axis.
    pub const ARKUI_LIST_ITEM_ALIGNMENT_START: ArkUI_ListItemAlignment = ArkUI_ListItemAlignment(0);
}
impl ArkUI_ListItemAlignment {
    /// The list items are centered in the list container along the cross axis.
    pub const ARKUI_LIST_ITEM_ALIGNMENT_CENTER: ArkUI_ListItemAlignment =
        ArkUI_ListItemAlignment(1);
}
impl ArkUI_ListItemAlignment {
    /// The list items are packed toward the end edge of the list container along the cross axis.
    pub const ARKUI_LIST_ITEM_ALIGNMENT_END: ArkUI_ListItemAlignment = ArkUI_ListItemAlignment(2);
}
#[repr(transparent)]
/** @brief Enumerates the alignment modes of items along the cross axis.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ListItemAlignment(pub ::core::ffi::c_uint);
impl ArkUI_BarrierDirection {
    /// The barrier is the leftmost of all its referencedIds.
    pub const ARKUI_BARRIER_DIRECTION_START: ArkUI_BarrierDirection = ArkUI_BarrierDirection(0);
}
impl ArkUI_BarrierDirection {
    /// The barrier is on the rightmost side of all its referencedIds.
    pub const ARKUI_BARRIER_DIRECTION_END: ArkUI_BarrierDirection = ArkUI_BarrierDirection(1);
}
impl ArkUI_BarrierDirection {
    /// The barrier is at the top of all its referencedIds.
    pub const ARKUI_BARRIER_DIRECTION_TOP: ArkUI_BarrierDirection = ArkUI_BarrierDirection(2);
}
impl ArkUI_BarrierDirection {
    /// The barrier is at the bottom of all its referencedIds.
    pub const ARKUI_BARRIER_DIRECTION_BOTTOM: ArkUI_BarrierDirection = ArkUI_BarrierDirection(3);
}
#[repr(transparent)]
/** @brief defines the direction of the barrier line.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_BarrierDirection(pub ::core::ffi::c_uint);
impl ArkUI_RelativeLayoutChainStyle {
    /// Components are evenly distributed among constraint anchor points.
    pub const ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_SPREAD: ArkUI_RelativeLayoutChainStyle =
        ArkUI_RelativeLayoutChainStyle(0);
}
impl ArkUI_RelativeLayoutChainStyle {
    /** Except for the first and last two sub-components,
    other components are evenly distributed between the constraint anchor points.*/
    pub const ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_SPREAD_INSIDE: ArkUI_RelativeLayoutChainStyle =
        ArkUI_RelativeLayoutChainStyle(1);
}
impl ArkUI_RelativeLayoutChainStyle {
    /// No gaps in subcomponents within the chain.
    pub const ARKUI_RELATIVE_LAYOUT_CHAIN_STYLE_PACKED: ArkUI_RelativeLayoutChainStyle =
        ArkUI_RelativeLayoutChainStyle(2);
}
#[repr(transparent)]
/** @brief defines the style of the chain.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_RelativeLayoutChainStyle(pub ::core::ffi::c_uint);
/** @brief Describes the margins of a component.

@since 12*/
#[repr(C)]
pub struct ArkUI_Margin {
    /// Top margin, in vp.
    pub top: f32,
    /// Right margin, in vp.
    pub right: f32,
    /// Bottom margin, in vp.
    pub bottom: f32,
    /// Left margin, in vp.
    pub left: f32,
}
impl ArkUI_LengthMetricUnit {
    /// Default, which is fp for fonts and vp for non-fonts.
    pub const ARKUI_LENGTH_METRIC_UNIT_DEFAULT: ArkUI_LengthMetricUnit = ArkUI_LengthMetricUnit(-1);
}
impl ArkUI_LengthMetricUnit {
    /// px.
    pub const ARKUI_LENGTH_METRIC_UNIT_PX: ArkUI_LengthMetricUnit = ArkUI_LengthMetricUnit(0);
}
impl ArkUI_LengthMetricUnit {
    /// vp.
    pub const ARKUI_LENGTH_METRIC_UNIT_VP: ArkUI_LengthMetricUnit = ArkUI_LengthMetricUnit(1);
}
impl ArkUI_LengthMetricUnit {
    /// fp.
    pub const ARKUI_LENGTH_METRIC_UNIT_FP: ArkUI_LengthMetricUnit = ArkUI_LengthMetricUnit(2);
}
#[repr(transparent)]
/** @brief Enumerates the component units.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_LengthMetricUnit(pub ::core::ffi::c_int);
impl ArkUI_RenderFit {
    /** Maintains the content size of the animation's final state,
    and the content is always centered with the component.*/
    pub const ARKUI_RENDER_FIT_CENTER: ArkUI_RenderFit = ArkUI_RenderFit(0);
}
impl ArkUI_RenderFit {
    /** Maintains the content size of the animation's final state,
    and the content is always aligned with the top center of the component.*/
    pub const ARKUI_RENDER_FIT_TOP: ArkUI_RenderFit = ArkUI_RenderFit(1);
}
impl ArkUI_RenderFit {
    /** Maintains the content size of the animation's final state,
    and the content is always aligned with the bottom center of the component.*/
    pub const ARKUI_RENDER_FIT_BOTTOM: ArkUI_RenderFit = ArkUI_RenderFit(2);
}
impl ArkUI_RenderFit {
    /** Maintains the content size of the animation's final state,
    and the content is always aligned to the left of the component.*/
    pub const ARKUI_RENDER_FIT_LEFT: ArkUI_RenderFit = ArkUI_RenderFit(3);
}
impl ArkUI_RenderFit {
    /** Maintains the content size of the animation's final state,
    and the content is always right-aligned with the component.*/
    pub const ARKUI_RENDER_FIT_RIGHT: ArkUI_RenderFit = ArkUI_RenderFit(4);
}
impl ArkUI_RenderFit {
    /** Maintains the content size of the animation's final state,
    and the content is always aligned with the top left corner of the component.*/
    pub const ARKUI_RENDER_FIT_TOP_LEFT: ArkUI_RenderFit = ArkUI_RenderFit(5);
}
impl ArkUI_RenderFit {
    /** Keep the content size of the animation final state,
    and the content is always aligned with the upper right corner of the component.*/
    pub const ARKUI_RENDER_FIT_TOP_RIGHT: ArkUI_RenderFit = ArkUI_RenderFit(6);
}
impl ArkUI_RenderFit {
    /** Keep the content size of the animation final state,
    and the content always aligns with the lower-left corner of the component.*/
    pub const ARKUI_RENDER_FIT_BOTTOM_LEFT: ArkUI_RenderFit = ArkUI_RenderFit(7);
}
impl ArkUI_RenderFit {
    /** Keep the content size of the animation final state,
    and the content always aligns with the lower-right corner of the component.*/
    pub const ARKUI_RENDER_FIT_BOTTOM_RIGHT: ArkUI_RenderFit = ArkUI_RenderFit(8);
}
impl ArkUI_RenderFit {
    /** The aspect ratio of the animation's final state content is not considered,
    and the content is always scaled to the size of the component.*/
    pub const ARKUI_RENDER_FIT_RESIZE_FILL: ArkUI_RenderFit = ArkUI_RenderFit(9);
}
impl ArkUI_RenderFit {
    /** Reduce or enlarge the aspect ratio of the animation final state content,
    so that the content is fully displayed in the component,
    and keep the center aligned with the component.*/
    pub const ARKUI_RENDER_FIT_RESIZE_CONTAIN: ArkUI_RenderFit = ArkUI_RenderFit(10);
}
impl ArkUI_RenderFit {
    /** Keep the aspect ratio of the animation final state content to reduce or enlarge,
    so that the content is fully displayed in the component.
    When there is left over in the broad direction of the component,
    the content is aligned to the left of the component,
    and when there is left over in the high direction of the component,
    the content is aligned to the top of the component.*/
    pub const ARKUI_RENDER_FIT_RESIZE_CONTAIN_TOP_LEFT: ArkUI_RenderFit = ArkUI_RenderFit(11);
}
impl ArkUI_RenderFit {
    /** Keep the aspect ratio of the animation final state content to reduce or enlarge,
    so that the content is fully displayed in the component.
    When there is left in the wide direction of the component,
    the content is aligned with the component on the right.
    When there is left in the high direction of the component,
    the content is aligned with the component on the bottom.*/
    pub const ARKUI_RENDER_FIT_RESIZE_CONTAIN_BOTTOM_RIGHT: ArkUI_RenderFit = ArkUI_RenderFit(12);
}
impl ArkUI_RenderFit {
    /** Keep the aspect ratio of the animation final state content reduced or enlarged,
    so that both sides of the content are greater than or equal to both sides of the component,
    and keep the center aligned with the component to display the middle part of the content.*/
    pub const ARKUI_RENDER_FIT_RESIZE_COVER: ArkUI_RenderFit = ArkUI_RenderFit(13);
}
impl ArkUI_RenderFit {
    /** Keep the aspect ratio of the final content of the animation reduced or enlarged
    so that both sides of the content are exactly greater than or equal to both sides of the component.
    When the content width is left, the content is aligned to the left of the component,
    and the left portion of the content is displayed. When the content is left in the high direction,
    the content and the component remain top aligned, showing the top side of the content.*/
    pub const ARKUI_RENDER_FIT_RESIZE_COVER_TOP_LEFT: ArkUI_RenderFit = ArkUI_RenderFit(14);
}
impl ArkUI_RenderFit {
    /** Keep the aspect ratio of the final content of the animation reduced or enlarged so
    that both sides of the content are exactly greater than or equal to both sides of the component.
    When the content width is left, the content and the component remain right aligned,
    and the right part of the content is displayed. When the content is left in the high direction,
    the content and the component remain aligned at the bottom,
    and the bottom part of the content is displayed.*/
    pub const ARKUI_RENDER_FIT_RESIZE_COVER_BOTTOM_RIGHT: ArkUI_RenderFit = ArkUI_RenderFit(15);
}
#[repr(transparent)]
/** @brief Enumerates the render fit.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_RenderFit(pub ::core::ffi::c_uint);
impl ArkUI_ButtonType {
    /// Normal button (without rounded corners by default).
    pub const ARKUI_BUTTON_TYPE_NORMAL: ArkUI_ButtonType = ArkUI_ButtonType(0);
}
impl ArkUI_ButtonType {
    /// Capsule-type button (the round corner is half of the height by default).
    pub const ARKUI_BUTTON_TYPE_CAPSULE: ArkUI_ButtonType = ArkUI_ButtonType(1);
}
impl ArkUI_ButtonType {
    /// Circle button.
    pub const ARKUI_BUTTON_TYPE_CIRCLE: ArkUI_ButtonType = ArkUI_ButtonType(2);
}
#[repr(transparent)]
/** @brief Enumerates the button types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ButtonType(pub ::core::ffi::c_uint);
impl ArkUI_TextInputContentType {
    /// Username. Password Vault, when enabled, can automatically save and fill in usernames.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_USER_NAME: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(0);
}
impl ArkUI_TextInputContentType {
    /// Password. Password Vault, when enabled, can automatically save and fill in passwords.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PASSWORD: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(1);
}
impl ArkUI_TextInputContentType {
    /// New password. Password Vault, when enabled, can automatically generate a new password.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_NEW_PASSWORD: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(2);
}
impl ArkUI_TextInputContentType {
    /** Full street address. The scenario-based autofill feature, when enabled, can automatically save and fill in full
    street addresses.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_FULL_STREET_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(3);
}
impl ArkUI_TextInputContentType {
    /** House number. The scenario-based autofill feature, when enabled, can automatically save and fill in house
    numbers.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_HOUSE_NUMBER: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(4);
}
impl ArkUI_TextInputContentType {
    /** District and county. The scenario-based autofill feature, when enabled, can automatically save and fill in
    districts and counties.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_DISTRICT_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(5);
}
impl ArkUI_TextInputContentType {
    /// City. The scenario-based autofill feature, when enabled, can automatically save and fill in cities.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_CITY_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(6);
}
impl ArkUI_TextInputContentType {
    /// Province. The scenario-based autofill feature, when enabled, can automatically save and fill in provinces.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PROVINCE_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(7);
}
impl ArkUI_TextInputContentType {
    /// Country. The scenario-based autofill feature, when enabled, can automatically save and fill in countries.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_COUNTRY_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(8);
}
impl ArkUI_TextInputContentType {
    /// Full name. The scenario-based autofill feature, when enabled, can automatically save and fill in full names.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_FULL_NAME: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(9);
}
impl ArkUI_TextInputContentType {
    /// Last name. The scenario-based autofill feature, when enabled, can automatically save and fill in last names.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_LAST_NAME: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(10);
}
impl ArkUI_TextInputContentType {
    /// First name. The scenario-based autofill feature, when enabled, can automatically save and fill in first names.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PERSON_FIRST_NAME: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(11);
}
impl ArkUI_TextInputContentType {
    /** Phone number. The scenario-based autofill feature, when enabled, can automatically save and fill in phone
    numbers.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PHONE_NUMBER: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(12);
}
impl ArkUI_TextInputContentType {
    /** Country code. The scenario-based autofill feature, when enabled, can automatically save and fill in country
    codes.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_PHONE_COUNTRY_CODE: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(13);
}
impl ArkUI_TextInputContentType {
    /** Phone number with country code. The scenario-based autofill feature, when enabled, can automatically save and
    fill in phone numbers with country codes.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_FULL_PHONE_NUMBER: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(14);
}
impl ArkUI_TextInputContentType {
    /** Email address. The scenario-based autofill feature, when enabled, can automatically save and fill in email
    addresses.*/
    pub const ARKUI_TEXTINPUT_CONTENT_EMAIL_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(15);
}
impl ArkUI_TextInputContentType {
    /** Bank card number. The scenario-based autofill feature, when enabled, can automatically save and fill in bank
    card numbers.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_BANK_CARD_NUMBER: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(16);
}
impl ArkUI_TextInputContentType {
    /** ID card number. The scenario-based autofill feature, when enabled, can automatically save and fill in ID card
    numbers.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_ID_CARD_NUMBER: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(17);
}
impl ArkUI_TextInputContentType {
    /// Nickname. The scenario-based autofill feature, when enabled, can automatically save and fill in nicknames.
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_NICKNAME: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(18);
}
impl ArkUI_TextInputContentType {
    /** Address information without street address. The scenario-based autofill feature, when enabled, can automatically
    save and fill in address information without street addresses.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_DETAIL_INFO_WITHOUT_STREET: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(19);
}
impl ArkUI_TextInputContentType {
    /** Standard address. The scenario-based autofill feature, when enabled, can automatically save and fill in standard
    addresses.*/
    pub const ARKUI_TEXTINPUT_CONTENT_TYPE_FORMAT_ADDRESS: ArkUI_TextInputContentType =
        ArkUI_TextInputContentType(20);
}
#[repr(transparent)]
/** @brief Enumerates the autofill types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextInputContentType(pub ::core::ffi::c_uint);
impl ArkUI_TextInputStyle {
    /** Default style. The caret width is fixed at 1.5 vp, and the caret height is subject to the background height and
    font size of the selected text.*/
    pub const ARKUI_TEXTINPUT_STYLE_DEFAULT: ArkUI_TextInputStyle = ArkUI_TextInputStyle(0);
}
impl ArkUI_TextInputStyle {
    /// Inline input style. The background height of the selected text is the same as the height of the text box.
    pub const ARKUI_TEXTINPUT_STYLE_INLINE: ArkUI_TextInputStyle = ArkUI_TextInputStyle(1);
}
#[repr(transparent)]
/** @brief Defines the text input style.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextInputStyle(pub ::core::ffi::c_uint);
impl ArkUI_TextDataDetectorType {
    /// Phone Number.
    pub const ARKUI_TEXT_DATA_DETECTOR_TYPE_PHONE_NUMBER: ArkUI_TextDataDetectorType =
        ArkUI_TextDataDetectorType(0);
}
impl ArkUI_TextDataDetectorType {
    /// Link.
    pub const ARKUI_TEXT_DATA_DETECTOR_TYPE_URL: ArkUI_TextDataDetectorType =
        ArkUI_TextDataDetectorType(1);
}
impl ArkUI_TextDataDetectorType {
    /// Mailbox.
    pub const ARKUI_TEXT_DATA_DETECTOR_TYPE_EMAIL: ArkUI_TextDataDetectorType =
        ArkUI_TextDataDetectorType(2);
}
impl ArkUI_TextDataDetectorType {
    /// Address.
    pub const ARKUI_TEXT_DATA_DETECTOR_TYPE_ADDRESS: ArkUI_TextDataDetectorType =
        ArkUI_TextDataDetectorType(3);
}
#[repr(transparent)]
/** @brief Defines the entity type for text recognition.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_TextDataDetectorType(pub ::core::ffi::c_uint);
impl ArkUI_SwiperIndicatorType {
    /// dot type.
    pub const ARKUI_SWIPER_INDICATOR_TYPE_DOT: ArkUI_SwiperIndicatorType =
        ArkUI_SwiperIndicatorType(0);
}
impl ArkUI_SwiperIndicatorType {
    /// digit type.
    pub const ARKUI_SWIPER_INDICATOR_TYPE_DIGIT: ArkUI_SwiperIndicatorType =
        ArkUI_SwiperIndicatorType(1);
}
#[repr(transparent)]
/** @brief Define the navigation indicator type of the swiper.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SwiperIndicatorType(pub ::core::ffi::c_uint);
impl ArkUI_ListItemSwipeActionState {
    /** In the folded state, when the ListItem slides in the opposite direction to the main axis,
    the operation item is hidden.*/
    pub const ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_COLLAPSED: ArkUI_ListItemSwipeActionState =
        ArkUI_ListItemSwipeActionState(0);
}
impl ArkUI_ListItemSwipeActionState {
    /** In the folded state, when the ListItem slides in the opposite direction to the spindle,
    the operation item is displayed.*/
    pub const ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_EXPANDED: ArkUI_ListItemSwipeActionState =
        ArkUI_ListItemSwipeActionState(1);
}
impl ArkUI_ListItemSwipeActionState {
    /// Long distance state, the state of deleting a ListItem after it enters the long distance deletion area.
    pub const ARKUI_LIST_ITEM_SWIPE_ACTION_STATE_ACTIONING: ArkUI_ListItemSwipeActionState =
        ArkUI_ListItemSwipeActionState(2);
}
#[repr(transparent)]
/** @brief Define the pattern of element arrangement in the main axis direction of the Swiper component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ListItemSwipeActionState(pub ::core::ffi::c_uint);
impl ArkUI_ListItemSwipeEdgeEffect {
    /// The ListItem can continue to be scratched after the distance exceeds the size of the scratched component.
    pub const ARKUI_LIST_ITEM_SWIPE_EDGE_EFFECT_SPRING: ArkUI_ListItemSwipeEdgeEffect =
        ArkUI_ListItemSwipeEdgeEffect(0);
}
impl ArkUI_ListItemSwipeEdgeEffect {
    /// The sliding distance of the ListItem cannot exceed the size of the scratched component.
    pub const ARKUI_LIST_ITEM_SWIPE_EDGE_EFFECT_NONE: ArkUI_ListItemSwipeEdgeEffect =
        ArkUI_ListItemSwipeEdgeEffect(1);
}
#[repr(transparent)]
/** @brief Define the explicit and implicit mode of the SwipeAction method for the Listitem component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ListItemSwipeEdgeEffect(pub ::core::ffi::c_uint);
impl ArkUI_ErrorCode {
    /// @error No errors.
    pub const ARKUI_ERROR_CODE_NO_ERROR: ArkUI_ErrorCode = ArkUI_ErrorCode(0);
}
impl ArkUI_ErrorCode {
    /// @error Parameter error.
    pub const ARKUI_ERROR_CODE_PARAM_INVALID: ArkUI_ErrorCode = ArkUI_ErrorCode(401);
}
impl ArkUI_ErrorCode {
    /// @error The component does not support specific properties or events.
    pub const ARKUI_ERROR_CODE_ATTRIBUTE_OR_EVENT_NOT_SUPPORTED: ArkUI_ErrorCode =
        ArkUI_ErrorCode(106102);
}
impl ArkUI_ErrorCode {
    /// @error The corresponding operation does not support nodes created by ArkTS.
    pub const ARKUI_ERROR_CODE_ARKTS_NODE_NOT_SUPPORTED: ArkUI_ErrorCode = ArkUI_ErrorCode(106103);
}
impl ArkUI_ErrorCode {
    /// @error The lazy loading adapter is not bound to the component.
    pub const ARKUI_ERROR_CODE_ADAPTER_NOT_BOUND: ArkUI_ErrorCode = ArkUI_ErrorCode(106104);
}
impl ArkUI_ErrorCode {
    /// @error The adapter already exists.
    pub const ARKUI_ERROR_CODE_ADAPTER_EXIST: ArkUI_ErrorCode = ArkUI_ErrorCode(106105);
}
impl ArkUI_ErrorCode {
    /// @error The corresponding node already has a child node and cannot add an adapter.
    pub const ARKUI_ERROR_CODE_CHILD_NODE_EXIST: ArkUI_ErrorCode = ArkUI_ErrorCode(106106);
}
impl ArkUI_ErrorCode {
    /// The parameter length in the parameter event exceeds the limit.
    pub const ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INDEX_OUT_OF_RANGE: ArkUI_ErrorCode =
        ArkUI_ErrorCode(106107);
}
impl ArkUI_ErrorCode {
    /// The data does not exist in the component event.
    pub const ARKUI_ERROR_CODE_NODE_EVENT_PARAM_INVALID: ArkUI_ErrorCode = ArkUI_ErrorCode(106108);
}
impl ArkUI_ErrorCode {
    /// The component event does not support return values.
    pub const ARKUI_ERROR_CODE_NODE_EVENT_NO_RETURN: ArkUI_ErrorCode = ArkUI_ErrorCode(106109);
}
impl ArkUI_ErrorCode {
    /// The index value is invalid.
    pub const ARKUI_ERROR_CODE_NODE_INDEX_INVALID: ArkUI_ErrorCode = ArkUI_ErrorCode(106200);
}
impl ArkUI_ErrorCode {
    ///  Failed to query route navigation information.
    pub const ARKUI_ERROR_CODE_GET_INFO_FAILED: ArkUI_ErrorCode = ArkUI_ErrorCode(106201);
}
impl ArkUI_ErrorCode {
    /// The buffer size is not large enough.
    pub const ARKUI_ERROR_CODE_BUFFER_SIZE_ERROR: ArkUI_ErrorCode = ArkUI_ErrorCode(106202);
}
impl ArkUI_ErrorCode {
    /// The component is not a scroll container.
    pub const ARKUI_ERROR_CODE_NON_SCROLLABLE_CONTAINER: ArkUI_ErrorCode = ArkUI_ErrorCode(180001);
}
impl ArkUI_ErrorCode {
    /// The buffer is not large enough.
    pub const ARKUI_ERROR_CODE_BUFFER_SIZE_NOT_ENOUGH: ArkUI_ErrorCode = ArkUI_ErrorCode(180002);
}
#[repr(transparent)]
/** @brief Define error code enumeration values.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ErrorCode(pub ::core::ffi::c_uint);
impl ArkUI_AnimationStatus {
    /// The animation is in the initial state.
    pub const ARKUI_ANIMATION_STATUS_INITIAL: ArkUI_AnimationStatus = ArkUI_AnimationStatus(0);
}
impl ArkUI_AnimationStatus {
    /// The animation is being played.
    pub const ARKUI_ANIMATION_STATUS_RUNNING: ArkUI_AnimationStatus = ArkUI_AnimationStatus(1);
}
impl ArkUI_AnimationStatus {
    /// The animation is paused.
    pub const ARKUI_ANIMATION_STATUS_PAUSED: ArkUI_AnimationStatus = ArkUI_AnimationStatus(2);
}
impl ArkUI_AnimationStatus {
    /// The animation is stopped.
    pub const ARKUI_ANIMATION_STATUS_STOPPED: ArkUI_AnimationStatus = ArkUI_AnimationStatus(3);
}
#[repr(transparent)]
/** @brief Defines the playback status for the image animator.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AnimationStatus(pub ::core::ffi::c_uint);
impl ArkUI_AnimationFillMode {
    /** Before execution, the animation does not apply any styles to the target component.
    After execution, the animation restores the target component to its default state.*/
    pub const ARKUI_ANIMATION_FILL_MODE_NONE: ArkUI_AnimationFillMode = ArkUI_AnimationFillMode(0);
}
impl ArkUI_AnimationFillMode {
    /** The target component retains the state set by the last keyframe encountered
    during execution of the animation.*/
    pub const ARKUI_ANIMATION_FILL_MODE_FORWARDS: ArkUI_AnimationFillMode =
        ArkUI_AnimationFillMode(1);
}
impl ArkUI_AnimationFillMode {
    /** The animation applies the values defined in the first relevant keyframe once it is applied to
    the target component, and retains the values during the period set by delay.*/
    pub const ARKUI_ANIMATION_FILL_MODE_BACKWARDS: ArkUI_AnimationFillMode =
        ArkUI_AnimationFillMode(2);
}
impl ArkUI_AnimationFillMode {
    /** The animation follows the rules for both Forwards and Backwards,
    extending the animation attributes in both directions.*/
    pub const ARKUI_ANIMATION_FILL_MODE_BOTH: ArkUI_AnimationFillMode = ArkUI_AnimationFillMode(3);
}
#[repr(transparent)]
/** @brief Defines the status before and after execution of the animation in the current playback direction.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AnimationFillMode(pub ::core::ffi::c_uint);
impl ArkUI_AccessibilityCheckedState {
    /// The Checkbox unchecked.
    pub const ARKUI_ACCESSIBILITY_UNCHECKED: ArkUI_AccessibilityCheckedState =
        ArkUI_AccessibilityCheckedState(0);
}
impl ArkUI_AccessibilityCheckedState {
    /// The Checkbox checked.
    pub const ARKUI_ACCESSIBILITY_CHECKED: ArkUI_AccessibilityCheckedState =
        ArkUI_AccessibilityCheckedState(1);
}
#[repr(transparent)]
/** @brief Defines the state type for the accessibility checkbox.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AccessibilityCheckedState(pub ::core::ffi::c_uint);
impl ArkUI_AccessibilityActionType {
    /// click action.
    pub const ARKUI_ACCESSIBILITY_ACTION_CLICK: ArkUI_AccessibilityActionType =
        ArkUI_AccessibilityActionType(1);
}
impl ArkUI_AccessibilityActionType {
    /// long click action.
    pub const ARKUI_ACCESSIBILITY_ACTION_LONG_CLICK: ArkUI_AccessibilityActionType =
        ArkUI_AccessibilityActionType(2);
}
impl ArkUI_AccessibilityActionType {
    /// cut action.
    pub const ARKUI_ACCESSIBILITY_ACTION_CUT: ArkUI_AccessibilityActionType =
        ArkUI_AccessibilityActionType(4);
}
impl ArkUI_AccessibilityActionType {
    /// copy action.
    pub const ARKUI_ACCESSIBILITY_ACTION_COPY: ArkUI_AccessibilityActionType =
        ArkUI_AccessibilityActionType(8);
}
impl ArkUI_AccessibilityActionType {
    /// paste action.
    pub const ARKUI_ACCESSIBILITY_ACTION_PASTE: ArkUI_AccessibilityActionType =
        ArkUI_AccessibilityActionType(16);
}
#[repr(transparent)]
/** @brief Define accessible action types.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AccessibilityActionType(pub ::core::ffi::c_uint);
impl ArkUI_AnimationDirection {
    /// The animation plays in forward loop mode.
    pub const ARKUI_ANIMATION_DIRECTION_NORMAL: ArkUI_AnimationDirection =
        ArkUI_AnimationDirection(0);
}
impl ArkUI_AnimationDirection {
    /// The animation plays in reverse loop mode.
    pub const ARKUI_ANIMATION_DIRECTION_REVERSE: ArkUI_AnimationDirection =
        ArkUI_AnimationDirection(1);
}
impl ArkUI_AnimationDirection {
    /** The animation plays in alternating loop mode. When the animation is played for an odd number of times, the
    playback is in forward direction. When the animation is played for an even number of times, the playback is in
    reverse direction.*/
    pub const ARKUI_ANIMATION_DIRECTION_ALTERNATE: ArkUI_AnimationDirection =
        ArkUI_AnimationDirection(2);
}
impl ArkUI_AnimationDirection {
    /** The animation plays in reverse alternating loop mode. When the animation is played for an odd number of times,
    the playback is in reverse direction. When the animation is played for an even number of times, the playback is
    in forward direction.*/
    pub const ARKUI_ANIMATION_DIRECTION_ALTERNATE_REVERSE: ArkUI_AnimationDirection =
        ArkUI_AnimationDirection(3);
}
#[repr(transparent)]
/** @brief Enumerates the animation playback modes.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_AnimationDirection(pub ::core::ffi::c_uint);
impl ArkUI_ScrollSource {
    /// Finger drag.
    pub const ARKUI_SCROLL_SOURCE_DRAG: ArkUI_ScrollSource = ArkUI_ScrollSource(0);
}
impl ArkUI_ScrollSource {
    /// Inertial roll after finger drag.
    pub const ARKUI_SCROLL_SOURCE_FLING: ArkUI_ScrollSource = ArkUI_ScrollSource(1);
}
impl ArkUI_ScrollSource {
    /// Execute the EdgeEffect.Spring edge effect when crossing the boundary.
    pub const ARKUI_SCROLL_SOURCE_EDGE_EFFECT: ArkUI_ScrollSource = ArkUI_ScrollSource(2);
}
impl ArkUI_ScrollSource {
    /// Other user input other than dragging, such as mouse wheel, keyboard events, etc.
    pub const ARKUI_SCROLL_SOURCE_OTHER_USER_INPUT: ArkUI_ScrollSource = ArkUI_ScrollSource(3);
}
impl ArkUI_ScrollSource {
    /// Drag the scroll bar.
    pub const ARKUI_SCROLL_SOURCE_SCROLL_BAR: ArkUI_ScrollSource = ArkUI_ScrollSource(4);
}
impl ArkUI_ScrollSource {
    /// Inertia scrolling after dragging the scroll bar.
    pub const ARKUI_SCROLL_SOURCE_SCROLL_BAR_FLING: ArkUI_ScrollSource = ArkUI_ScrollSource(5);
}
impl ArkUI_ScrollSource {
    /// The scroll controller causes unanimated scrolling.
    pub const ARKUI_SCROLL_SOURCE_SCROLLER: ArkUI_ScrollSource = ArkUI_ScrollSource(6);
}
impl ArkUI_ScrollSource {
    /// The scroll controller causes the scroll to drive the painting.
    pub const ARKUI_SCROLL_SOURCE_ANIMATION: ArkUI_ScrollSource = ArkUI_ScrollSource(7);
}
#[repr(transparent)]
/** @brief Define the rolling source enumeration value.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_ScrollSource(pub ::core::ffi::c_uint);
/** @brief Defines the translation options for component transition.

@since 12*/
#[repr(C)]
pub struct ArkUI_TranslationOptions {
    /// Translation distance along the x-axis.
    pub x: f32,
    /// Translation distance along the y-axis.
    pub y: f32,
    /// Translation distance along the z-axis.
    pub z: f32,
}
/** @brief Defines the scaling options for component transition.

@since 12*/
#[repr(C)]
pub struct ArkUI_ScaleOptions {
    /// Scale ratio along the x-axis.
    pub x: f32,
    /// Scale ratio along the y-axis.
    pub y: f32,
    /// Scale factor along the z-axis (not effective for the current 2D graphics).
    pub z: f32,
    /// X coordinate of the center point.
    pub centerX: f32,
    /// Y coordinate of the center point.
    pub centerY: f32,
}
/** @brief Defines the rotation options for component transition.

@since 12*/
#[repr(C)]
pub struct ArkUI_RotationOptions {
    /// X-component of the rotation vector.
    pub x: f32,
    /// Y-component of the rotation vector.
    pub y: f32,
    /// Z-component of the rotation vector.
    pub z: f32,
    /// Rotation angle.
    pub angle: f32,
    /// X coordinate of the center point.
    pub centerX: f32,
    /// Y coordinate of the center point.
    pub centerY: f32,
    /// Z-axis anchor, that is, the z-component of the 3D rotation center point.
    pub centerZ: f32,
    /// Distance from the user to the z=0 plane.
    pub perspective: f32,
}
#[repr(C)]
pub struct ArkUI_CustomSpanMeasureInfo {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_CustomSpanMetrics {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct ArkUI_CustomSpanDrawInfo {
    _unused: [u8; 0],
}
impl ArkUI_NavDestinationState {
    /// The NavDestination show.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_SHOW: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(0);
}
impl ArkUI_NavDestinationState {
    /// The NavDestination hide.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_HIDE: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(1);
}
impl ArkUI_NavDestinationState {
    /// The NavDestination is mounted to the component tree.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_APPEAR: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(2);
}
impl ArkUI_NavDestinationState {
    /// The NavDestination removed from the component tree.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_DISAPPEAR: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(3);
}
impl ArkUI_NavDestinationState {
    /// Before the NavDestination show.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_WILL_SHOW: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(4);
}
impl ArkUI_NavDestinationState {
    /// Before the NavDestination hide.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_WILL_HIDE: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(5);
}
impl ArkUI_NavDestinationState {
    /// Before the NavDestination mount to the component tree.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_WILL_APPEAR: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(6);
}
impl ArkUI_NavDestinationState {
    /// Before the NavDestination removed from the component tree.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_WILL_DISAPPEAR: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(7);
}
impl ArkUI_NavDestinationState {
    /// The NavDestination returns from the component.
    pub const ARKUI_NAV_DESTINATION_STATE_ON_BACK_PRESS: ArkUI_NavDestinationState =
        ArkUI_NavDestinationState(100);
}
#[repr(transparent)]
/** @brief Defines the state of the NavDestination component.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_NavDestinationState(pub ::core::ffi::c_uint);
impl ArkUI_RouterPageState {
    /// The Router Page is about to be created.
    pub const ARKUI_ROUTER_PAGE_STATE_ABOUT_TO_APPEAR: ArkUI_RouterPageState =
        ArkUI_RouterPageState(0);
}
impl ArkUI_RouterPageState {
    /// The Router Page is about to be destroyed.
    pub const ARKUI_ROUTER_PAGE_STATE_ABOUT_TO_DISAPPEAR: ArkUI_RouterPageState =
        ArkUI_RouterPageState(1);
}
impl ArkUI_RouterPageState {
    /// The Router Page show.
    pub const ARKUI_ROUTER_PAGE_STATE_ON_SHOW: ArkUI_RouterPageState = ArkUI_RouterPageState(2);
}
impl ArkUI_RouterPageState {
    /// The Router Page hide.
    pub const ARKUI_ROUTER_PAGE_STATE_ON_HIDE: ArkUI_RouterPageState = ArkUI_RouterPageState(3);
}
impl ArkUI_RouterPageState {
    /// The Router Page returns.
    pub const ARKUI_ROUTER_PAGE_STATE_ON_BACK_PRESS: ArkUI_RouterPageState =
        ArkUI_RouterPageState(4);
}
#[repr(transparent)]
/** @brief Define the state of Router Page.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_RouterPageState(pub ::core::ffi::c_uint);
impl ArkUI_SafeAreaType {
    /// The default security zone includes the status bar and navigation bar.
    pub const ARKUI_SAFE_AREA_TYPE_SYSTEM: ArkUI_SafeAreaType = ArkUI_SafeAreaType(1);
}
impl ArkUI_SafeAreaType {
    /// Non-secure areas of the device, such as bangs or hole holes.
    pub const ARKUI_SAFE_AREA_TYPE_CUTOUT: ArkUI_SafeAreaType = ArkUI_SafeAreaType(2);
}
impl ArkUI_SafeAreaType {
    /// Soft keyboard area.
    pub const ARKUI_SAFE_AREA_TYPE_KEYBOARD: ArkUI_SafeAreaType = ArkUI_SafeAreaType(4);
}
#[repr(transparent)]
/** @brief defines the enumerated value of the extended security zone.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SafeAreaType(pub ::core::ffi::c_uint);
impl ArkUI_SafeAreaEdge {
    /// Upper area.
    pub const ARKUI_SAFE_AREA_EDGE_TOP: ArkUI_SafeAreaEdge = ArkUI_SafeAreaEdge(1);
}
impl ArkUI_SafeAreaEdge {
    /// Lower area.
    pub const ARKUI_SAFE_AREA_EDGE_BOTTOM: ArkUI_SafeAreaEdge = ArkUI_SafeAreaEdge(2);
}
impl ArkUI_SafeAreaEdge {
    /// Front area.
    pub const ARKUI_SAFE_AREA_EDGE_START: ArkUI_SafeAreaEdge = ArkUI_SafeAreaEdge(4);
}
impl ArkUI_SafeAreaEdge {
    /// Tail area.
    pub const ARKUI_SAFE_AREA_EDGE_END: ArkUI_SafeAreaEdge = ArkUI_SafeAreaEdge(8);
}
#[repr(transparent)]
/** @brief defines the enumerated value of the direction of the extended security zone.

@since 12*/
#[derive(Clone, Hash, PartialEq, Eq)]
pub struct ArkUI_SafeAreaEdge(pub ::core::ffi::c_uint);
#[repr(C)]
pub struct ArkUI_SystemFontStyleEvent {
    _unused: [u8; 0],
}
extern "C" {
    /** @brief Creates a size constraint.

    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_Create() -> *mut ArkUI_LayoutConstraint;
    /** @brief Creates a deep copy of a size constraint.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the pointer to the new size constraint.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_Copy(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> *mut ArkUI_LayoutConstraint;
    /** @brief Destroys the pointer to a size constraint.

    @param Constraint Indicates the pointer to the size constraint.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_Dispose(
        Constraint: *mut ArkUI_LayoutConstraint,
    ) -> *mut ::core::ffi::c_void;
    /** @brief Obtains the maximum width for a size constraint, in px.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the maximum width.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_GetMaxWidth(Constraint: *const ArkUI_LayoutConstraint) -> i32;
    /** @brief Obtains the minimum width for a size constraint, in px.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the minimum width.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_GetMinWidth(Constraint: *const ArkUI_LayoutConstraint) -> i32;
    /** @brief Obtains the maximum height for a size constraint, in px.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the maximum height.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_GetMaxHeight(Constraint: *const ArkUI_LayoutConstraint)
        -> i32;
    /** @brief Obtains the minimum height for a size constraint, in px.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the minimum height.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_GetMinHeight(Constraint: *const ArkUI_LayoutConstraint)
        -> i32;
    /** @brief Obtains the width percentage reference for a size constraint, in px.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the width percentage reference.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_GetPercentReferenceWidth(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> i32;
    /** @brief Obtains the height percentage reference for a size constraint, in px.

    @param Constraint Indicates the pointer to the size constraint.
    @return Returns the height percentage reference.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_GetPercentReferenceHeight(
        Constraint: *const ArkUI_LayoutConstraint,
    ) -> i32;
    /** @brief Sets the maximum width.

    @param Constraint Indicates the pointer to the size constraint.
    @param value Indicates the maximum width, in px.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_SetMaxWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
    /** @brief Sets the minimum width.

    @param Constraint Indicates the pointer to the size constraint.
    @param value Indicates the minimum width, in px.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_SetMinWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
    /** @brief Sets the maximum height.

    @param Constraint Indicates the pointer to the size constraint.
    @param value Indicates the maximum height, in px.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_SetMaxHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
    /** @brief Sets the minimum height.

    @param Constraint Indicates the pointer to the size constraint.
    @param value Indicates the minimum height, in px.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_SetMinHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
    /** @brief Sets the width percentage reference.

    @param Constraint Indicates the pointer to the size constraint.
    @param value Indicates the width percentage reference, in px.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_SetPercentReferenceWidth(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
    /** @brief Sets the height percentage reference.

    @param Constraint Indicates the pointer to the size constraint.
    @param value Indicates the height percentage reference, in px.
    @since 12*/
    pub fn OH_ArkUI_LayoutConstraint_SetPercentReferenceHeight(
        Constraint: *mut ArkUI_LayoutConstraint,
        value: i32,
    );
    /** @brief Obtains the pointer to a canvas for drawing, which can be converted into the <b>OH_Drawing_Canvas</b> pointer
    in the <b>Drawing</b> module.

    @param context Indicates the pointer to the drawing context.
    @return Returns the pointer to the canvas for drawing.
    @since 12*/
    pub fn OH_ArkUI_DrawContext_GetCanvas(
        context: *mut ArkUI_DrawContext,
    ) -> *mut ::core::ffi::c_void;
    /** @brief Obtains the size of a drawing area.

    @param context Indicates the pointer to the drawing context.
    @return Returns the size of the drawing area.
    @since 12*/
    pub fn OH_ArkUI_DrawContext_GetSize(context: *mut ArkUI_DrawContext) -> ArkUI_IntSize;
    /** @brief Creates water flow section configuration.

    @return Returns the water flow section configuration.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_Create() -> *mut ArkUI_WaterFlowSectionOption;
    /** @brief Destroys the pointer to a water flow section configuration.

    @param option Indicates the pointer to a water flow section configuration.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_Dispose(option: *mut ArkUI_WaterFlowSectionOption);
    /** @brief Sets the FlowItem block configuration information array length.

    @param option FlowItem Indicates the packet configuration.
    @param size Array Length.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_SetSize(
        option: *mut ArkUI_WaterFlowSectionOption,
        size: i32,
    );
    /** @brief Gets the FlowItem grouping configuration information array length.

    @param option FlowItem Indicates the packet configuration.
    @return Array size. If -1 is returned, the return fails.
            The possible cause of the failure is that the option parameter is abnormal, such as a null pointer.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_GetSize(
        option: *mut ArkUI_WaterFlowSectionOption,
    ) -> i32;
    /** @brief Sets the number of items in a water flow section.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param itemCount Indicates the number of items in the water flow section.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_SetItemCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        itemCount: i32,
    );
    /** @brief Obtains the number of items in the water flow section that matches the specified index.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @return Returns the number of items in the water flow section.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_GetItemCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> i32;
    /** @brief The FlowItem grouping configuration information getsthe spindle size of
    the specified Item based on flowItemIndex.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param callback Gets the spindle size of the specified Item based on index.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_RegisterGetItemMainSizeCallbackByIndex(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        callback: ::core::option::Option<unsafe extern "C" fn(itemIndex: i32) -> f32>,
    );
    /** @brief The FlowItem grouping configuration information getsthe spindle size of
    the specified Item based on flowItemIndex.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param userData FlowItem Custom data.
    @param callback Gets the spindle size of the specified Item based on index.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_RegisterGetItemMainSizeCallbackByIndexWithUserData(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        userData: *mut ::core::ffi::c_void,
        callback: ::core::option::Option<
            unsafe extern "C" fn(itemIndex: i32, userData: *mut ::core::ffi::c_void) -> f32,
        >,
    );
    /** @brief Sets the number of columns (in a vertical layout) or rows (in a horizontal layout) of a water flow.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param crossCount Indicates the number of columns or rows, depending on the layout direction.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_SetCrossCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        crossCount: i32,
    );
    /** @brief Obtains the number of columns (in a vertical layout) or rows (in a horizontal layout) in the water flow section
    that matches the specified index.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @return Returns the number of columns or rows.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_GetCrossCount(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> i32;
    /** @brief Sets the gap between columns in the specified water flow section.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param columnGap Indicates the gap between columns to set.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_SetColumnGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        columnGap: f32,
    );
    /** @brief Obtains the gap between columns in the water flow section that matches the specified index.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @return Returns the gap between columns.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_GetColumnGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> f32;
    /** @brief Sets the gap between rows in the specified water flow section.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param rowGap Indicates the gap between rows to set.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_SetRowGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        rowGap: f32,
    );
    /** @brief Obtains the gap between rows in the water flow section that matches the specified index.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @return Returns the gap between rows.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_GetRowGap(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> f32;
    /** @brief Sets the margins for the specified water flow section.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @param marginTop Indicates the top margin of the water flow section.
    @param marginRight Indicates the right margin of the water flow section.
    @param marginBottom Indicates the bottom margin of the water flow section.
    @param marginLeft Indicates the left margin of the water flow section.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_SetMargin(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
        marginTop: f32,
        marginRight: f32,
        marginBottom: f32,
        marginLeft: f32,
    );
    /** @brief Obtains the margins of the water flow section that matches the specified index.

    @param option Indicates the pointer to a water flow section configuration.
    @param index Indicates the index of the target water flow section.
    @return Returns the margins.
    @since 12*/
    pub fn OH_ArkUI_WaterFlowSectionOption_GetMargin(
        option: *mut ArkUI_WaterFlowSectionOption,
        index: i32,
    ) -> ArkUI_Margin;
    /** @brief Creates a navigation indicator.

    @param type Indicates the type of the indicator.
    @return Returns the pointer to the new indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_Create(
        type_: ArkUI_SwiperIndicatorType,
    ) -> *mut ArkUI_SwiperIndicator;
    /** @brief Destroys the pointer to the indicator.

    @param indicator Indicates the pointer to the indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_Dispose(indicator: *mut ArkUI_SwiperIndicator);
    /** @brief Sets the distance between the navigation point and the start of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the distance between the navigation point and the start of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetStartPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief Obtains the distance between the navigation point and the start of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the distance between the navigation point and the start of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetStartPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
    /** @brief Sets the distance between the navigation point and the top of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the distance between the navigation point and the top of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetTopPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief Obtains the distance between the navigation point and the top of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the distance between the navigation point and the top of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetTopPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
    /** @brief Sets the distance between the navigation point and the right of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the distance between the navigation point and the right of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetEndPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief Obtains the distance between the navigation point and the end of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the distance between the navigation point and the end of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetEndPosition(indicator: *mut ArkUI_SwiperIndicator) -> f32;
    /** @brief Sets the distance between the navigation point and the bottom of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the distance between the navigation point and the bottom of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetBottomPosition(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief Obtains the distance between the navigation point and the bottom of the swiper.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the distance between the navigation point and the bottom of the swiper.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetBottomPosition(indicator: *mut ArkUI_SwiperIndicator)
        -> f32;
    /** @brief Sets the width of the dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the width of the dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetItemWidth(indicator: *mut ArkUI_SwiperIndicator, value: f32);
    /** @brief Obtains the width of the dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the width of the dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetItemWidth(indicator: *mut ArkUI_SwiperIndicator) -> f32;
    /** @brief Sets the height of the dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the height of the dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief  Obtains the height of the dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the height of the dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetItemHeight(indicator: *mut ArkUI_SwiperIndicator) -> f32;
    /** @brief Sets the width of the selected dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the width of the selected dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedItemWidth(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief  Obtains the width of the selected dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the width of the selected dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedItemWidth(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> f32;
    /** @brief Sets the height of the selected dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @param value Indicates the height of the selected dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
        value: f32,
    );
    /** @brief  Obtains the height of the selected dot for the dot indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the height of the selected dot for the dot indicator.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedItemHeight(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> f32;
    /** @brief Sets whether to display the mask style of the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @param mask Whether to display the mask style. True means to display.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetMask(indicator: *mut ArkUI_SwiperIndicator, mask: i32);
    /** @brief Obtains whether to display the mask style of the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns whether to display the mask style. True means to display.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetMask(indicator: *mut ArkUI_SwiperIndicator) -> i32;
    /** @brief Sets the color of the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @param color the color of the dot navigation indicator, in 0xARGB format.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetColor(indicator: *mut ArkUI_SwiperIndicator, color: u32);
    /** @brief Obtains the color of the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the color of the dot navigation indicator, in 0xARGB format.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetColor(indicator: *mut ArkUI_SwiperIndicator) -> u32;
    /** @brief Sets the color of the selected dot for the navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @param color the color of the selected dot, in 0xARGB format.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetSelectedColor(
        indicator: *mut ArkUI_SwiperIndicator,
        selectedColor: u32,
    );
    /** @brief Obtains the color of the selected dot for the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the color of the selected dot, in 0xARGB format.
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetSelectedColor(indicator: *mut ArkUI_SwiperIndicator) -> u32;
    /** @brief Sets the number of maxDisplayCount for the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @param maxDisplayCount the maxDisplayCount of the navigation dot, span is 6-9.
    @return {@link ARKUI_ERROR_CODE_NO_ERROR} Success.
            {@link ARKUI_ERROR_CODE_PARAM_INVALID} indicator is null or maxDisplayCount less then 6 or
            maxDisplayCount more then 9
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_SetMaxDisplayCount(
        indicator: *mut ArkUI_SwiperIndicator,
        maxDisplayCount: i32,
    ) -> i32;
    /** @brief Obtains the number of maxDisplayCount for the dot navigation indicator.

    @param indicator Indicates the pointer to the indicator.
    @return Returns the number of the maxDisplayCount, span is 6-9.
            0 - indicator is null
    @since 12*/
    pub fn OH_ArkUI_SwiperIndicator_GetMaxDisplayCount(
        indicator: *mut ArkUI_SwiperIndicator,
    ) -> i32;
    /** @brief Create auxiliary line information in the RelativeContaine container.

    @param size The number of auxiliary lines.
    @return auxiliary line information.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_Create(size: i32) -> *mut ArkUI_GuidelineOption;
    /** @brief Destroy auxiliary line information.

    @param guideline auxiliary line information.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_Dispose(guideline: *mut ArkUI_GuidelineOption);
    /** @brief Set the Id of the auxiliary line.

    @param guideline auxiliary line information.
    @param value id, must be unique and cannot have the same name as the component in the container.
    @param index auxiliary line index value.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_SetId(
        guideline: *mut ArkUI_GuidelineOption,
        value: *const ::core::ffi::c_char,
        index: i32,
    );
    /** @brief Set the direction of the auxiliary line.

    @param guideline auxiliary line information.
    @param value direction.
    @param index auxiliary line index value.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_SetDirection(
        guideline: *mut ArkUI_GuidelineOption,
        value: ArkUI_Axis,
        index: i32,
    );
    /** @brief Set the distance from the left or top of the container.

    @param guideline auxiliary line information.
    @param value The distance from the left or top of the container.
    @param index auxiliary line index value.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_SetPositionStart(
        guideline: *mut ArkUI_GuidelineOption,
        value: f32,
        index: i32,
    );
    /** @brief Set the distance from the right or bottom of the container.

    @param guideline auxiliary line information.
    @param value The distance from the right side or bottom of the container.
    @param index auxiliary line index value.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_SetPositionEnd(
        guideline: *mut ArkUI_GuidelineOption,
        value: f32,
        index: i32,
    );
    /** @brief Get the Id of the auxiliary line.

    @param guideline auxiliary line information.
    @param index auxiliary line index value.
    @return Id.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_GetId(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> *const ::core::ffi::c_char;
    /** @brief Get the direction of the auxiliary line.

    @param guideline auxiliary line information.
    @param index auxiliary line index value.
    @return direction.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_GetDirection(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> ArkUI_Axis;
    /** @brief Get the distance from the left or top of the container.

    @param guideline auxiliary line information.
    @param index auxiliary line index value.
    @return The distance from the left or top of the container.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_GetPositionStart(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> f32;
    /** @brief Get the distance from the right side or bottom of the container.

    @param guideline auxiliary line information.
    @param index auxiliary line index value.
    @return The distance from the right side or bottom of the container.
    @since 12*/
    pub fn OH_ArkUI_GuidelineOption_GetPositionEnd(
        guideline: *mut ArkUI_GuidelineOption,
        index: i32,
    ) -> f32;
    /** @brief creates barrier information within the RelativeContaine container.

    @param size Number of barriers.
    @return barrier information.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_Create(size: i32) -> *mut ArkUI_BarrierOption;
    /** @brief Destroy barrier information.

    @param barrierStyle barrier information.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_Dispose(barrierStyle: *mut ArkUI_BarrierOption);
    /** @brief Set the Id of the barrier.

    @param barrierStyle barrier information.
    @param value id, must be unique and cannot have the same name as the component in the container.
    @param index Barrier index value.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_SetId(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: *const ::core::ffi::c_char,
        index: i32,
    );
    /** @brief Set the direction of the barrier.

    @param barrierStyle barrier information.
    @param value direction.
    @param index Barrier index value.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_SetDirection(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: ArkUI_BarrierDirection,
        index: i32,
    );
    /** @brief Sets the dependent component of the barrier.

    @param barrierStyle barrier information.
    @param value The ID of the dependent component.
    @param index Barrier index value.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_SetReferencedId(
        barrierStyle: *mut ArkUI_BarrierOption,
        value: *const ::core::ffi::c_char,
        index: i32,
    );
    /** @brief Get the Id of the barrier.

    @param barrierStyle auxiliary line information.
    @param index auxiliary line index value.
    @return The Id of the barrier.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_GetId(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> *const ::core::ffi::c_char;
    /** @brief Gets the direction of the barrier.

    @param barrierStyle auxiliary line information.
    @param index auxiliary line index value.
    @return The direction of the barrier.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_GetDirection(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> ArkUI_BarrierDirection;
    /** @brief Get the dependent components of the barrier.

    @param barrierStyle auxiliary line information.
    @param index auxiliary line index value.
    @param referencedIndex dependent component Id index value.
    @return The barrier's dependent components.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_GetReferencedId(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
        referencedIndex: i32,
    ) -> *const ::core::ffi::c_char;
    /** @brief Gets the number of dependent components of the barrier.

    @param barrierStyle auxiliary line information.
    @param index auxiliary line index value.
    @return The number of dependent components of the barrier.
    @since 12*/
    pub fn OH_ArkUI_BarrierOption_GetReferencedIdSize(
        barrierStyle: *mut ArkUI_BarrierOption,
        index: i32,
    ) -> i32;
    /** @brief creates alignment rule information for subcomponents in relative containers.

    @return Alignment rule information.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_Create() -> *mut ArkUI_AlignmentRuleOption;
    /** @brief Destroys the alignment rule information of subcomponents in relative containers.

    @param option Alignment rule information of subcomponents in the relative container.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_Dispose(option: *mut ArkUI_AlignmentRuleOption);
    /** @brief Set the start alignment parameter.

    @param option Alignment rule information of subcomponents in the relative container.
    @param id The id value of the anchor component.
    @param value Alignment relative to the anchor component.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetStart(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::core::ffi::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
    /** @brief Set the end alignment parameter.

    @param option Alignment rule information of subcomponents in the relative container.
    @param id The id value of the anchor component.
    @param value Alignment relative to the anchor component.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetEnd(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::core::ffi::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
    /** @brief Set the parameters for horizontal center alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @param id The id value of the anchor component.
    @param value Alignment relative to anchor component
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetCenterHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::core::ffi::c_char,
        alignment: ArkUI_HorizontalAlignment,
    );
    /** @brief Set the parameters for top alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @param id The id value of the anchor component.
    @param value Alignment relative to anchor component
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetTop(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::core::ffi::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
    /** @brief Set the bottom alignment parameters.

    @param option Alignment rule information of subcomponents in the relative container.
    @param id The id value of the anchor component.
    @param value Alignment relative to anchor component
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetBottom(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::core::ffi::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
    /** @brief Set the parameters for vertical center alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @param id The id value of the anchor component.
    @param value Alignment relative to the anchor component.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetCenterVertical(
        option: *mut ArkUI_AlignmentRuleOption,
        id: *const ::core::ffi::c_char,
        alignment: ArkUI_VerticalAlignment,
    );
    /** @brief Sets the horizontal offset parameter of the component under the anchor point constraint.

    @param option Alignment rule information of subcomponents in the relative container.
    @param horizontal bias value in the horizontal direction.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetBiasHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
        horizontal: f32,
    );
    /** @brief Set the vertical offset parameter of the component under the anchor point constraint.

    @param option Alignment rule information of subcomponents in the relative container.
    @param horizontal bias value in the vertical direction.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_SetBiasVertical(
        option: *mut ArkUI_AlignmentRuleOption,
        vertical: f32,
    );
    /** @brief Get the Id of the start-aligned parameter.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The id value of the anchor component.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetStartId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::core::ffi::c_char;
    /** @brief Gets the alignment of the start-aligned parameter.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The alignment of the parameters.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetStartAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
    /** @brief Get the end alignment parameter.

    @param option Alignment rule information of subcomponents in the relative container.
    @return End-aligned parameter id.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetEndId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::core::ffi::c_char;
    /** @brief Get the end alignment parameter.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The alignment of the end-aligned parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetEndAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
    /** @brief Gets the parameters of horizontal center alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The id of the parameter of horizontal center alignment.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterIdHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::core::ffi::c_char;
    /** @brief Gets the parameters of horizontal center alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The alignment of the horizontally centered alignment parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterAlignmentHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_HorizontalAlignment;
    /** @brief Get the top-aligned parameters.

    @param option Alignment rule information of subcomponents in the relative container.
    @return Top aligned parameter id.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetTopId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::core::ffi::c_char;
    /** @brief Get the top-aligned parameters.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The alignment of the top-aligned parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetTopAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
    /** @brief Get the bottom alignment parameters.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The id of the bottom-aligned parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetBottomId(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::core::ffi::c_char;
    /** @brief Get the bottom alignment parameters.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The alignment of the bottom-aligned parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetBottomAlignment(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
    /** @brief Gets the parameters of vertical center alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The id of the vertical center alignment parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterIdVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> *const ::core::ffi::c_char;
    /** @brief Gets the parameters of vertical center alignment.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The alignment of the vertical center alignment parameter.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetCenterAlignmentVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> ArkUI_VerticalAlignment;
    /** @brief Get the bias value in the horizontal direction.

    @param option Alignment rule information of subcomponents in the relative container.
    @return The bias value in the horizontal direction.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetBiasHorizontal(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> f32;
    /** @brief Get the bias value in the vertical direction.

    @param option Alignment rule information of subcomponents in the relative container.
    @return bias value in vertical direction.
    @since 12*/
    pub fn OH_ArkUI_AlignmentRuleOption_GetBiasVertical(
        option: *mut ArkUI_AlignmentRuleOption,
    ) -> f32;
    /** @brief Create a configuration item for the ListitemSwipeActionItem interface settings.

    @return List Item SwipeActionItem configuration item instance. If the object returns a null pointer,
            it indicates creation failure, and the reason for the failure may be that the address space is full.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_Create() -> *mut ArkUI_ListItemSwipeActionItem;
    /** @brief Destroy the ListitemSwipeActionItem instance.

    @param option List Item SwipeActionItem instance to be destroyed.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_Dispose(item: *mut ArkUI_ListItemSwipeActionItem);
    /** @brief Set the layout content of ListItem SwipeActionItem.

    @param option List Item SwipeActionItem instance.
    @param builder Layout information.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetContent(
        item: *mut ArkUI_ListItemSwipeActionItem,
        node: ArkUI_NodeHandle,
    );
    /** @brief Set the threshold for long-distance sliding deletion distance of components.

    @param option List Item SwipeActionItem instance.
    @param distance Component long-distance sliding deletion distance threshold.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetActionAreaDistance(
        item: *mut ArkUI_ListItemSwipeActionItem,
        distance: f32,
    );
    /** @brief Obtain the threshold for long-distance sliding deletion distance of components.

    @param option List Item SwipeActionItem instance.
    @return Component long-distance sliding deletion distance threshold. If -1.0f is returned, the return fails.
            The possible cause of the failure is that the item parameter is abnormal, such as a null pointer.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_GetActionAreaDistance(
        item: *mut ArkUI_ListItemSwipeActionItem,
    ) -> f32;
    /** @brief Set the event to be called when a sliding entry enters the deletion area.

    @param option List Item SwipeActionItem instance.
    @param callback Callback Events.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnEnterActionArea(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
    /** @brief Set the event triggered when a sliding entry enters the deletion area.

    @param option List Item SwipeActionItem instance.
    @param userData User defined data.
    @param callback Callback Events.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnEnterActionAreaWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::core::ffi::c_void,
        callback: ::core::option::Option<unsafe extern "C" fn(userData: *mut ::core::ffi::c_void)>,
    );
    /** @brief Set the event to be called when a component enters the long-range deletion area and deletes a ListItem.

    @param option List Item SwipeActionItem instance.
    @param callback Callback Events.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnAction(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
    /** @brief Set the event triggered when a component enters the long-range deletion area and deletes a ListItem.

    @param option List Item SwipeActionItem instance.
    @param userData User defined data.
    @param callback Callback Events.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnActionWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::core::ffi::c_void,
        callback: ::core::option::Option<unsafe extern "C" fn(userData: *mut ::core::ffi::c_void)>,
    );
    /** @brief Set the event to be called when a sliding entry exits the deletion area.

    @param option List Item SwipeActionItem instance.
    @param callback Callback Events.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnExitActionArea(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
    /** @brief Set the event triggered when a sliding entry exits the deletion area.

    @param option List Item SwipeActionItem instance.
    @param userData User defined data.
    @param callback Callback Events.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnExitActionAreaWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::core::ffi::c_void,
        callback: ::core::option::Option<unsafe extern "C" fn(userData: *mut ::core::ffi::c_void)>,
    );
    /** @brief Set the event triggered when the sliding state of a list item changes.

    @param option List Item SwipeActionItem instance.
    @param callback Callback Events.
           swipeActionState The changed state.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnStateChange(
        item: *mut ArkUI_ListItemSwipeActionItem,
        callback: ::core::option::Option<
            unsafe extern "C" fn(swipeActionState: ArkUI_ListItemSwipeActionState),
        >,
    );
    /** @brief Set the event triggered when the sliding state of a list item changes.

    @param option List Item SwipeActionItem instance.
    @param userData User defined data.
    @param callback Callback Events.
           swipeActionState The changed state.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionItem_SetOnStateChangeWithUserData(
        item: *mut ArkUI_ListItemSwipeActionItem,
        userData: *mut ::core::ffi::c_void,
        callback: ::core::option::Option<
            unsafe extern "C" fn(
                swipeActionState: ArkUI_ListItemSwipeActionState,
                userData: *mut ::core::ffi::c_void,
            ),
        >,
    );
    /** @brief Create a configuration item for the ListitemSwipeActionOption interface settings.

    @return List Item SwipeActionOption configuration item instance.If the object returns a null pointer,
            it indicates a creation failure, and the reason for the failure may be that the address space is full.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_Create() -> *mut ArkUI_ListItemSwipeActionOption;
    /** @brief Destroy the ListitemSwipeActionOption instance.

    @param option List Item SwipeActionOption instance to be destroyed.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_Dispose(option: *mut ArkUI_ListItemSwipeActionOption);
    /** @brief Set the layout content on the left (vertical layout) or top (horizontal layout)
    of the ListItem SwipeActionItem.

    @param option List Item SwipeActionItem instance.
    @param builder Layout information.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetStart(
        option: *mut ArkUI_ListItemSwipeActionOption,
        item: *mut ArkUI_ListItemSwipeActionItem,
    );
    /** @brief Set the layout content on the right (vertical layout) or bottom (horizontal layout)
    of the ListItem SwipeActionItem.

    @param option List Item SwipeActionItem instance.
    @param builder Layout information.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetEnd(
        option: *mut ArkUI_ListItemSwipeActionOption,
        item: *mut ArkUI_ListItemSwipeActionItem,
    );
    /** @brief Set the sliding effect.

    @param option List Item SwipeActionItem instance.
    @param edgeEffect Sliding effect.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetEdgeEffect(
        option: *mut ArkUI_ListItemSwipeActionOption,
        edgeEffect: ArkUI_ListItemSwipeEdgeEffect,
    );
    /** @brief Get the sliding effect.

    @param option List Item SwipeActionItem instance.
    @return Sliding effect. The default return value is 0. If -1 is returned, the return fails.
            The possible cause of the failure is that the option parameter is abnormal, such as a null pointer.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_GetEdgeEffect(
        option: *mut ArkUI_ListItemSwipeActionOption,
    ) -> i32;
    /** @brief The event called when the sliding operation offset changes.

    @param option List Item SwipeActionItem instance.
    @param callback Callback Events.
           offset Slide offset.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetOnOffsetChange(
        option: *mut ArkUI_ListItemSwipeActionOption,
        callback: ::core::option::Option<unsafe extern "C" fn(offset: f32)>,
    );
    /** @brief Set the event triggered when the sliding operation offset changes.

    @param option List Item SwipeActionItem instance.
    @param userData User defined data.
    @param callback Callback Events.
           offset Slide offset.
    @since 12*/
    pub fn OH_ArkUI_ListItemSwipeActionOption_SetOnOffsetChangeWithUserData(
        option: *mut ArkUI_ListItemSwipeActionOption,
        userData: *mut ::core::ffi::c_void,
        callback: ::core::option::Option<
            unsafe extern "C" fn(offset: f32, userData: *mut ::core::ffi::c_void),
        >,
    );
    /** @brief Create configuration items for the ListChildrenMainSize interface settings.

    @return ListChildrenMainSize configuration item instance.If the object returns a null pointer,
            it indicates a creation failure, and the reason for the failure may be that the address space is full.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Create() -> *mut ArkUI_ListChildrenMainSize;
    /** @brief Destroy the ListChildrenMainSize instance.

    @param option The ListChildrenMainSize instance to be destroyed.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Dispose(option: *mut ArkUI_ListChildrenMainSize);
    /** @brief Set the default size of ChildrenMainSizeOption for the List component.

    @param option ListChildrenMainSize instance.
    @param defaultMainSize The default size of the ListItem under the List, measured in vp.
    @return 0 represents success. If defaultMainSize is less than 0 or option is a null pointer, return 401.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_SetDefaultMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
        defaultMainSize: f32,
    ) -> i32;
    /** @brief Get the default size of ChildrenMainSizeOption for the List component.

    @param option ListChildrenMainSize instance.
    @return The default size of the ListItem under the List is 0, measured in vp.
            When the option is a null pointer, it returns -1.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_GetDefaultMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
    ) -> f32;
    /** @brief Reset the array size of ChildrenMainSizeOption for the List component.

    @param option ListChildrenMainSize instance.
    @param totalSize Array size.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Resize(
        option: *mut ArkUI_ListChildrenMainSize,
        totalSize: i32,
    );
    /** @brief Resize the ChildrenMainSizeOption array operation on the List component.

    @param option ListChildrenMainSize instance.
    @param index To modify the starting position of the MainSize array.
    @param deleteCount The number of MainSize arrays to be deleted starting from index.
    @param addCount The number of MainSize arrays to be added starting from index.
    @return 0 represents success. If the function parameter is abnormal, return 401.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_Splice(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
        deleteCount: i32,
        addCount: i32,
    ) -> i32;
    /** @brief Update the value of the ChildrenMainSizeOption array in the List component.

    @param option ListChildrenMainSize instance.
    @param index To modify the starting position of the MainSize array.
    @param mainSize The actual modified value.
    @return 0 represents success. If the function parameter is abnormal, return 401.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_UpdateSize(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
        mainSize: f32,
    ) -> i32;
    /** @brief Get the value of the ChildrenMainSizeOption array for the List component.

    @param option ListChildrenMainSize instance.
    @param index The index position of the value to be obtained.
    @return The value of the specific position of the array. If the function parameter is abnormal, return -1.
    @since 12*/
    pub fn OH_ArkUI_ListChildrenMainSizeOption_GetMainSize(
        option: *mut ArkUI_ListChildrenMainSize,
        index: i32,
    ) -> f32;
    /** @brief Creates measurement information for this custom span.

    @return Returns a <b>CustomSpanMeasureInfo</b> instance.
    <br> If the result returns nullptr, there may be out of memory.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMeasureInfo_Create() -> *mut ArkUI_CustomSpanMeasureInfo;
    /** @brief Disposes of measurement information of this custom span.

    @param info The CustomSpanMeasureInfo instance to be destroyed.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMeasureInfo_Dispose(info: *mut ArkUI_CustomSpanMeasureInfo);
    /** @brief Obtains the font size of a custom span.

    @param info Indicates the pointer to the measurement information of a custom span.
    @return Returns the font size. If a parameter error occurs, <b>0.0f</b> is returned.
    <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMeasureInfo_GetFontSize(
        info: *mut ArkUI_CustomSpanMeasureInfo,
    ) -> f32;
    /** @brief Creates measurement metrics for this custom span.

    @return Returns a <b>CustomSpanMetrics</b> instance.
    <br> If the result returns nullptr, there may be out of memory.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMetrics_Create() -> *mut ArkUI_CustomSpanMetrics;
    /** @brief Disposes of measurement metrics of this custom span.

    @param info The CustomSpanMetrics instance to be destroyed.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMetrics_Dispose(metrics: *mut ArkUI_CustomSpanMetrics);
    /** @brief Sets the width for a custom span.

    @param metrics Indicates the pointer to a <b>CustomSpanMetrics</b> instance.
    @param width Indicates the width, in px. The width should be greater than 0.
    @return Returns the result code.
            Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.
            Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.
            <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMetrics_SetWidth(
        metrics: *mut ArkUI_CustomSpanMetrics,
        width: f32,
    ) -> i32;
    /** @brief Sets the height for a custom span.

    @param metrics Indicates the pointer to a <b>CustomSpanMetrics</b> instance.
    @param width Indicates the height, in px. The width should be greater than 0.
    @return Returns the result code.
            Returns {@link ARKUI_ERROR_CODE_NO_ERROR} if the operation is successful.
            Returns {@link ARKUI_ERROR_CODE_PARAM_INVALID} if a parameter error occurs.
            <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanMetrics_SetHeight(
        metrics: *mut ArkUI_CustomSpanMetrics,
        height: f32,
    ) -> i32;
    /** @brief Creates drawing information for this custom span.

    @return Returns a <b>CustomSpanDrawInfo</b> instance.
    <br> If the result returns nullptr, there may be out of memory.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanDrawInfo_Create() -> *mut ArkUI_CustomSpanDrawInfo;
    /** @brief Disposes of drawing information for this custom span.

    @param info The CustomSpanDrawInfo instance to be destroyed.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanDrawInfo_Dispose(info: *mut ArkUI_CustomSpanDrawInfo);
    /** @brief Obtains the x-axis offset of the custom span relative to the mounted component.

    @param info Indicates the pointer to the drawing information of a custom span.
    @return Returns the x-axis offset. If a parameter error occurs, <b>0.0f</b> is returned.
    <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetXOffset(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
    /** @brief Obtains the top margin of the custom span relative to the mounted component.

    @param info Indicates the pointer to the drawing information of a custom span.
    @return Returns the top margin. If a parameter error occurs, <b>0.0f</b> is returned.
    <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetLineTop(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
    /** @brief Obtains the bottom margin of the custom span relative to the mounted component.

    @param info Indicates the pointer to the drawing information of a custom span.
    @return Returns the bottom margin. If a parameter error occurs, <b>0.0f</b> is returned.
    <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetLineBottom(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
    /** @brief Obtains the baseline offset of the custom span relative to the mounted component.

    @param info Indicates the pointer to the drawing information of a custom span.
    @return Returns the baseline offset. If a parameter error occurs, <b>0.0f</b> is returned.
    <br> Possible causes: Parameter verification failed, the parameter should not be nullptr.
    @since 12*/
    pub fn OH_ArkUI_CustomSpanDrawInfo_GetBaseline(info: *mut ArkUI_CustomSpanDrawInfo) -> f32;
    /** @brief Create a image frame from the image path.
    @param src Indicates the image path.
    @return Returns the pointer to the image frame object.
    If a null pointer is returned, the object fails to be created. The possible cause is that
    the src parameter is abnormal, for example, the pointer is null.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_CreateFromString(
        src: *mut ::core::ffi::c_char,
    ) -> *mut ArkUI_ImageAnimatorFrameInfo;
    /** @brief Destroy the pointer to the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_Dispose(imageInfo: *mut ArkUI_ImageAnimatorFrameInfo);
    /** @brief Set the width of the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @param width Indicates the width of the image frame, and the unit is PX.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetWidth(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        width: i32,
    );
    /** @brief Get the width of the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @return Return the width of the image frame, and the unit is PX. Return 0 when the imageInfo is null.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetWidth(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
    /** @brief Set the height of the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @param height Indicates the height of the image frame, and the unit is PX.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetHeight(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        height: i32,
    );
    /** @brief Get the height of the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @return Return the height of the image frame, and the unit is PX. Return 0 when the imageInfo is null.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetHeight(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
    /** @brief Set the vertical coordinate of the image relative to the upper left corner of the widget.

    @param imageInfo Indicates the pointer to the image frame.
    @param top Indicates the vertical coordinate of the image relative to the upper left corner of the widget,
    and the unit is PX.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetTop(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        top: i32,
    );
    /** @brief Get the vertical coordinate of the image relative to the upper left corner of the widget.

    @param imageInfo Indicates the pointer to the image frame.
    @return Returns the vertical coordinate of the image relative to the upper left corner of the widget,
    and the unit is PX. Return 0 when the imageInfo is null.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetTop(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
    /** @brief Set the horizontal coordinate of the image relative to the upper left corner of the widget.

    @param imageInfo Indicates the pointer to the image frame.
    @param left Indicates the horizontal coordinate of the image relative to the upper left corner of the widget,
    and the unit is PX.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetLeft(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        left: i32,
    );
    /** @brief Get the horizontal coordinate of the image relative to the upper left corner of the widget.

    @param imageInfo Indicates the pointer to the image frame.
    @return Returns the horizontal coordinate of the image relative to the upper left corner of the widget,
    and the unit is PX. Return 0 when the imageInfo is null.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetLeft(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
    /** @brief Set the playback duration of the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @param duration Indicates the playback duration of each image frame, and the unit is milliseconds.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_SetDuration(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
        duration: i32,
    );
    /** @brief Get the playback duration of the image frame.

    @param imageInfo Indicates the pointer to the image frame.
    @return Returns the playback duration of the image frame, and the unit is milliseconds.
    Return 0 when the imageInfo is null.
    @since 12*/
    pub fn OH_ArkUI_ImageAnimatorFrameInfo_GetDuration(
        imageInfo: *mut ArkUI_ImageAnimatorFrameInfo,
    ) -> i32;
    /** @brief Create accessibility state.

    @return Returns the pointer to the accessibility state object.
    If a null pointer is returned, the object fails to be created. The possible cause is that the address space is full.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_Create() -> *mut ArkUI_AccessibilityState;
    /** @brief Dispose accessibility state.

    @param state accessibility state object.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_Dispose(state: *mut ArkUI_AccessibilityState);
    /** @brief Set accessibility state disabled.

    @param state accessibility state object.
    @param isDisabled accessibility state disabled， Value 1 indicates disabled and 0 indicates enbled.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_SetDisabled(
        state: *mut ArkUI_AccessibilityState,
        isDisabled: i32,
    );
    /** @brief Get accessibility state disabled.

    @param state accessibility state object.
    @return accessibility state disabled， Value 1 indicates disabled and 0 indicates enbled. The default value is 0.
            If the function parameter is abnormal, return the default value.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_IsDisabled(state: *mut ArkUI_AccessibilityState) -> i32;
    /** @brief Set accessibility state selected.

    @param state accessibility state object.
    @param isSelected accessibility state selected， Value 1 indicates selected， and 0 indicates not selected.
           The default value is 0.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_SetSelected(
        state: *mut ArkUI_AccessibilityState,
        isSelected: i32,
    );
    /** @brief Get accessibility state selected.

    @param state accessibility state object.
    @return accessibility state selected， Value 1 indicates selected， and 0 indicates not selected.
            The default value is 0.
            If the function parameter is abnormal, return the default value.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_IsSelected(state: *mut ArkUI_AccessibilityState) -> i32;
    /** @brief Set accessibility checked state.

    @param state accessibility state object.
    @param checkedState checked state，and uses the {@link ArkUI_AccessibilityCheckedState} enumeration value,
           The default value is ARKUI_ACCESSIBILITY_UNCHECKED.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_SetCheckedState(
        state: *mut ArkUI_AccessibilityState,
        checkedState: i32,
    );
    /** @brief Get accessibility checked state.

    @param state accessibility state object.
    @return checked state，and uses the {@link ArkUI_AccessibilityCheckedState} enumeration value,
            The default value is ARKUI_ACCESSIBILITY_UNCHECKED.
            If the function parameter is abnormal, return the default value.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityState_GetCheckedState(state: *mut ArkUI_AccessibilityState)
        -> i32;
    /** @brief Create accessibility value.

    @return Returns the pointer to the accessibility state object.
    If a null pointer is returned, the object fails to be created. The possible cause is that the address space is full.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_Create() -> *mut ArkUI_AccessibilityValue;
    /** @brief Dispose accessibility value.

    @param state accessibility value object.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_Dispose(value: *mut ArkUI_AccessibilityValue);
    /** @brief Set accessibility minimum value.

    @param value accessibility value object.
    @param min minimum value based on range components, The default value is -1。
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_SetMin(value: *mut ArkUI_AccessibilityValue, min: i32);
    /** @brief Get accessibility minimum value.

    @param value accessibility value object.
    @return minimum value based on range components, The default value is -1。
            If the function parameter is abnormal, return -1.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_GetMin(value: *mut ArkUI_AccessibilityValue) -> i32;
    /** @brief Set accessibility minimum value.

    @param value accessibility value object.
    @param max maximum value based on range components, The default value is -1。
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_SetMax(value: *mut ArkUI_AccessibilityValue, max: i32);
    /** @brief Get accessibility minimum value.

    @param value accessibility value object.
    @return maximum value based on range components, The default value is -1。
            If the function parameter is abnormal, return -1.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_GetMax(value: *mut ArkUI_AccessibilityValue) -> i32;
    /** @brief Set accessibility current value.

    @param value accessibility value object.
    @param current value based on range components, The default value is -1。
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_SetCurrent(
        value: *mut ArkUI_AccessibilityValue,
        current: i32,
    );
    /** @brief Get accessibility current value.

    @param value accessibility value object.
    @return current value based on range components, The default value is -1。
            If the function parameter is abnormal, return -1.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_GetCurrent(value: *mut ArkUI_AccessibilityValue) -> i32;
    /** @brief Set accessibility text value.

    @param value accessibility value object.
    @param text The textual description information of the component, which defaults to an empty string。
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_SetText(
        value: *mut ArkUI_AccessibilityValue,
        text: *const ::core::ffi::c_char,
    );
    /** @brief Get accessibility text value。

    @param value accessibility value object.
    @return The textual description information of the component, which defaults to an empty string;
            If the function parameter is abnormal, return null.
    @since 12*/
    pub fn OH_ArkUI_AccessibilityValue_GetText(
        value: *mut ArkUI_AccessibilityValue,
    ) -> *const ::core::ffi::c_char;
}
