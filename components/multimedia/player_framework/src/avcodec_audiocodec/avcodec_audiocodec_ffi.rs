// automatically generated by rust-bindgen 0.71.1

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(deprecated)]
#[allow(unused_imports)]
use crate::avbuffer::OH_AVBuffer;
#[allow(unused_imports)]
use crate::avcodec_base::{OH_AVCodec, OH_AVCodecCallback};
#[allow(unused_imports)]
use crate::averrors::OH_AVErrCode;
#[allow(unused_imports)]
use crate::avformat::OH_AVFormat;

/// MediaKeySession field.
///
/// Available since API-level: 12
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
#[repr(C)]
pub struct MediaKeySession {
    _unused: [u8; 0],
}
extern "C" {
    /// Create an audio encoder or decoder instance from the mime type, which is recommended in most cases.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `mime` - mime type description string, refer to [`AVCODEC_MIME_TYPE`]
    ///
    /// * `isEncoder` - true indicates the need to create an encoder, while false indicates the need to create a decoder.
    ///
    /// # Returns
    ///
    /// * Returns a Pointer to an OH_AVCodec instance
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_CreateByMime(
        mime: *const ::core::ffi::c_char,
        isEncoder: bool,
    ) -> *mut OH_AVCodec;
    /// Create an audio codec instance through the audio codec name.
    /// The premise of using this interface is to know the exact name of the codec.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `name` - Audio codec name
    ///
    /// # Returns
    ///
    /// * Returns a Pointer to an OH_AVCodec instance
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_CreateByName(name: *const ::core::ffi::c_char) -> *mut OH_AVCodec;
    /// Clear the internal resources of the codec and destroy the codec instance
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], the codec is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_NO_MEMORY`], inner resource has already released.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Destroy(codec: *mut OH_AVCodec) -> OH_AVErrCode;
    /// Set the asynchronous callback function so that your application
    /// can respond to the events generated by the audio codec. This interface must be called before Prepare is called.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `callback` - A collection of all callback functions, see [`OH_AVCodecCallback`]
    ///
    /// * `userData` - User specific data
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_RegisterCallback(
        codec: *mut OH_AVCodec,
        callback: OH_AVCodecCallback,
        userData: *mut ::core::ffi::c_void,
    ) -> OH_AVErrCode;
    /// To configure the audio codec, typically, you need to configure the description information of the
    /// audio track. This interface must be called before Prepare is called.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `format` - A pointer to an OH_AVFormat giving a description of the audio track to be encoded or decoded
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Configure(
        codec: *mut OH_AVCodec,
        format: *const OH_AVFormat,
    ) -> OH_AVErrCode;
    /// To prepare the internal resources of the codec, the Configure interface must be called
    /// before calling this interface.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], the codec is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Prepare(codec: *mut OH_AVCodec) -> OH_AVErrCode;
    /// Start the codec, this interface must be called after the Prepare is successful.
    /// After being successfully started, the codec will start reporting NeedInputData events.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], the codec is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Start(codec: *mut OH_AVCodec) -> OH_AVErrCode;
    /// Stop the codec. After stopping, you can re-enter the Started state through Start,
    /// but it should be noted that need to re-enter if the codec has been input before
    /// Codec-Specific-Data.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], the codec is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Stop(codec: *mut OH_AVCodec) -> OH_AVErrCode;
    /// Clear the input and output data buffered in the codec. After this interface is called, all the Buffer
    /// indexes previously reported through the asynchronous callback will be invalidated, make sure not to access
    /// the Buffers corresponding to these indexes.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], the codec is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Flush(codec: *mut OH_AVCodec) -> OH_AVErrCode;
    /// Reset the codec. To continue encoding or decoding, you need to call the Configure interface again to
    /// configure the codec instance.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], the codec is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_Reset(codec: *mut OH_AVCodec) -> OH_AVErrCode;
    /// Get the description information of the output data of the codec, refer to [`OH_AVFormat`] for details.
    /// It should be noted that the life cycle of the OH_AVFormat instance pointed to by the return value * needs to
    /// be manually released by calling [`OH_AVFormat_Destroy`].
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// # Returns
    ///
    /// * Returns the OH_AVFormat handle pointer, the life cycle is refreshed with
    /// the next [`OH_AudioCodec_GetOutputDescription`], or destroyed with OH_AVCodec;
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_GetOutputDescription(codec: *mut OH_AVCodec) -> *mut OH_AVFormat;
    /// Set dynamic parameters to the codec. Note: This interface can only be called after the codec is started.
    /// At the same time, incorrect parameter settings may cause encoding or decoding failure.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `format` - OH_AVFormat handle pointer
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid.
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_SetParameter(
        codec: *mut OH_AVCodec,
        format: *const OH_AVFormat,
    ) -> OH_AVErrCode;
    /// Submit the input buffer filled with data to the audio codec. The [`OH_AVCodecOnNeedInputBuffer`] callback
    /// will report the available input buffer and the corresponding index value. Once the buffer with the specified index
    /// is submitted to the audio codec, the buffer cannot be accessed again until the [`OH_AVCodecOnNeedInputBuffer`]
    /// callback is received again reporting that the buffer with the same index is available. In addition, for some
    /// codecs, it is required to input Codec-Specific-Data to the codec at the beginning to initialize the encoding or
    /// decoding process of the codec.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `index` - Enter the index value corresponding to the Buffer
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid. Buffer index
    /// should be given by [`OH_AVCodecOnNeedInputBuffer`].
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_PushInputBuffer(codec: *mut OH_AVCodec, index: u32) -> OH_AVErrCode;
    /// Return the processed output Buffer to the codec.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `index` - The index value corresponding to the output Buffer
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid. Buffer index
    /// should be given by [`OH_AVCodecOnNewOutputBuffer`].
    /// [`AV_ERR_INVALID_STATE`], the interface was called in an invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], operation not permitted.
    /// This could be due to an incorrect state or an unsupported operation.
    /// [`AV_ERR_UNKNOWN`], internal error occurred, it is recommended to check the logs.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_FreeOutputBuffer(codec: *mut OH_AVCodec, index: u32) -> OH_AVErrCode;
    /// Check whether the current codec instance is valid. It can be used fault recovery or app
    /// switchback from the background
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `isValid` - Output Parameter. A pointer to a boolean instance, it is true if the codec instance is valid,
    /// false if the codec instance is invalid
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`]
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid.
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub fn OH_AudioCodec_IsValid(codec: *mut OH_AVCodec, isValid: *mut bool) -> OH_AVErrCode;
    /// Set decryption info.
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `mediaKeySession` - A media key session instance with decryption function.
    ///
    /// * `secureAudio` - Require secure decoder or not.
    ///
    /// # Returns
    ///
    /// * [`AV_ERR_OK`] 0 - Success
    /// [`AV_ERR_INVALID_VAL`] 3 - If the codec instance is nullptr or invalid,
    /// the mediaKeySession is nullptr or invalid.
    /// [`AV_ERR_INVALID_STATE`] 8 - If the codec service is invalid.
    /// [`AV_ERR_NO_MEMORY`], failed to request memory.
    ///
    /// Available since API-level: 12
    ///
    /// Version: 1.0
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub fn OH_AudioCodec_SetDecryptionConfig(
        codec: *mut OH_AVCodec,
        mediaKeySession: *mut MediaKeySession,
        secureAudio: bool,
    ) -> OH_AVErrCode;
    /// Queries the index of the next available input buffer.
    ///
    /// This API must be followed by calling [`OH_AudioCodec_GetInputBuffer`] to obtain the buffer handle,
    /// which should then be passed to the codec via [`OH_AudioCodec_PushInputBuffer`].
    ///
    /// Note: This operation is only supported in synchronous mode.
    ///
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance.
    ///
    /// * `index` - The index of the input buffer.
    ///
    /// * `timeoutUs` - Timeout duration in microseconds, negative value indicates infinite wait.
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`].
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid.
    /// [`AV_ERR_INVALID_STATE`], this interface was called in invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], not permitted in asynchronous mode.
    /// [`AV_ERR_TRY_AGAIN_LATER`], query failed, recommended retry after delay.
    ///
    /// Available since API-level: 20
    #[cfg(feature = "api-20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-20")))]
    pub fn OH_AudioCodec_QueryInputBuffer(
        codec: *mut OH_AVCodec,
        index: *mut u32,
        timeoutUs: i64,
    ) -> OH_AVErrCode;
    /// Acquires the handle of an available input buffer.
    ///
    /// Note: It's only applicable in synchronous mode.
    ///
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `index` - Buffer index obtained via [`OH_AudioCodec_QueryInputBuffer`].
    ///
    /// # Returns
    ///
    /// * Returns a Pointer to an OH_AVBuffer instance.
    /// Return nullptr if no buffer available.
    ///
    /// Available since API-level: 20
    #[cfg(feature = "api-20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-20")))]
    pub fn OH_AudioCodec_GetInputBuffer(codec: *mut OH_AVCodec, index: u32) -> *mut OH_AVBuffer;
    /// Queries the index of the next available output buffer.
    ///
    /// The obtained buffer handle through [`OH_AudioCodec_GetOutputBuffer`] must be
    /// return to the audio codec via [`OH_AudioCodec_FreeOutputBuffer`].
    ///
    /// Note: This operation is only supported in synchronous mode.
    ///
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `index` - The index of the output buffer
    ///
    /// * `timeoutUs` - Timeout duration in microseconds, negative value indicates infinite wait.
    ///
    /// # Returns
    ///
    /// * Returns AV_ERR_OK if the execution is successful,
    /// otherwise returns a specific error code, refer to [`OH_AVErrCode`].
    /// [`AV_ERR_INVALID_VAL`], input parameter is empty or invalid.
    /// [`AV_ERR_INVALID_STATE`], this interface was called in invalid state.
    /// [`AV_ERR_OPERATE_NOT_PERMIT`], not permitted in asynchronous mode.
    /// [`AV_ERR_STREAM_CHANGED`], stream format changed, call [`OH_AudioCodec_GetOutputDescription`] to
    /// retrieve new steam information.
    /// [`AV_ERR_TRY_AGAIN_LATER`], query failed, recommended retry after delay.
    ///
    /// Available since API-level: 20
    #[cfg(feature = "api-20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-20")))]
    pub fn OH_AudioCodec_QueryOutputBuffer(
        codec: *mut OH_AVCodec,
        index: *mut u32,
        timeoutUs: i64,
    ) -> OH_AVErrCode;
    /// Get the available output buffer handle.
    ///
    /// Note: This operation is only supported in synchronous mode.
    ///
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.AudioCodec
    /// # Arguments
    ///
    /// * `codec` - Pointer to an OH_AVCodec instance
    ///
    /// * `index` - The index value corresponding to the output buffer,
    /// should be given by [`OH_AudioCodec_QueryOutputBuffer`].
    ///
    /// # Returns
    ///
    /// * Returns a Pointer to an OH_AVBuffer instance.
    /// Return nullptr if no buffer available.
    ///
    /// Available since API-level: 20
    #[cfg(feature = "api-20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-20")))]
    pub fn OH_AudioCodec_GetOutputBuffer(codec: *mut OH_AVCodec, index: u32) -> *mut OH_AVBuffer;
}
