// automatically generated by rust-bindgen 0.71.1

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#[cfg(feature = "api-11")]
use crate::avbuffer::OH_AVBuffer;
use crate::avbuffer_info::OH_AVCodecBufferAttr;
#[allow(unused_imports)]
use crate::averrors::OH_AVErrCode;
use crate::avformat::OH_AVFormat;
use crate::avmemory::OH_AVMemory;

/// Forward declaration of OH_AVCodec.
///
///
/// Available since API-level: 9
#[repr(C)]
pub struct OH_AVCodec {
    _unused: [u8; 0],
}
/// When an error occurs in the running of the OH_AVCodec instance, the function pointer will be called
/// to report specific error information.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `codec` - OH_AVCodec instance
///
/// * `errorCode` - specific error code
///
/// * `userData` - User specific data
///
/// Available since API-level: 9
pub type OH_AVCodecOnError = ::core::option::Option<
    unsafe extern "C" fn(
        codec: *mut OH_AVCodec,
        errorCode: i32,
        userData: *mut ::core::ffi::c_void,
    ),
>;
/// When the output stream changes, the function pointer will be called to report the new stream description
/// information. It should be noted that the life cycle of the OH_AVFormat pointer
/// is only valid when the function pointer is called, and it is forbidden to continue to access after the call ends.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `codec` - OH_AVCodec instance
///
/// * `format` - New output stream description information
///
/// * `userData` - User specific data
///
/// Available since API-level: 9
pub type OH_AVCodecOnStreamChanged = ::core::option::Option<
    unsafe extern "C" fn(
        codec: *mut OH_AVCodec,
        format: *mut OH_AVFormat,
        userData: *mut ::core::ffi::c_void,
    ),
>;
/// When OH_AVCodec needs new input data during the running process,
/// the function pointer will be called and carry an available Buffer to fill in the new input data.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `codec` - OH_AVCodec instance
///
/// * `index` - The index corresponding to the newly available input buffer.
///
/// * `data` - New available input buffer.
///
/// * `userData` - User specific data
///
/// **Deprecated** since 11
/// OH_AVCodecOnNeedInputBuffer
///
/// Available since API-level: 9
pub type OH_AVCodecOnNeedInputData = ::core::option::Option<
    unsafe extern "C" fn(
        codec: *mut OH_AVCodec,
        index: u32,
        data: *mut OH_AVMemory,
        userData: *mut ::core::ffi::c_void,
    ),
>;
/// When new output data is generated during the operation of OH_AVCodec, the function pointer will be
/// called and carry a Buffer containing the new output data. It should be noted that the life cycle of the
/// OH_AVCodecBufferAttr pointer is only valid when the function pointer is called. , which prohibits continued
/// access after the call ends.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `codec` - OH_AVCodec instance
///
/// * `index` - The index corresponding to the new output Buffer.
///
/// * `data` - Buffer containing the new output data
///
/// * `attr` - The description of the new output Buffer, please refer to [`OH_AVCodecBufferAttr`]
///
/// * `userData` - specified data
///
/// **Deprecated** since 11
/// OH_AVCodecOnNewOutputBuffer
///
/// Available since API-level: 9
pub type OH_AVCodecOnNewOutputData = ::core::option::Option<
    unsafe extern "C" fn(
        codec: *mut OH_AVCodec,
        index: u32,
        data: *mut OH_AVMemory,
        attr: *mut OH_AVCodecBufferAttr,
        userData: *mut ::core::ffi::c_void,
    ),
>;
/// When OH_AVCodec needs new input data during the running process,
/// the function pointer will be called and carry an available Buffer to fill in the new input data.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `codec` - OH_AVCodec instance
///
/// * `index` - The index corresponding to the newly available input buffer.
///
/// * `buffer` - New available input buffer.
///
/// * `userData` - User specific data
///
/// Available since API-level: 11
#[cfg(feature = "api-11")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
pub type OH_AVCodecOnNeedInputBuffer = ::core::option::Option<
    unsafe extern "C" fn(
        codec: *mut OH_AVCodec,
        index: u32,
        buffer: *mut OH_AVBuffer,
        userData: *mut ::core::ffi::c_void,
    ),
>;
/// When new output data is generated during the operation of OH_AVCodec, the function pointer will be
/// called and carry a Buffer containing the new output data.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `codec` - OH_AVCodec instance
///
/// * `index` - The index corresponding to the new output Buffer.
///
/// * `buffer` - Buffer containing the new output buffer.
///
/// * `userData` - specified data
///
/// Available since API-level: 11
#[cfg(feature = "api-11")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
pub type OH_AVCodecOnNewOutputBuffer = ::core::option::Option<
    unsafe extern "C" fn(
        codec: *mut OH_AVCodec,
        index: u32,
        buffer: *mut OH_AVBuffer,
        userData: *mut ::core::ffi::c_void,
    ),
>;
/// A collection of all asynchronous callback function pointers in OH_AVCodec. Register an instance of this
/// structure to the OH_AVCodec instance, and process the information reported through the callback to ensure the
/// normal operation of OH_AVCodec.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `onError` - Monitor OH_AVCodec operation errors, refer to [`OH_AVCodecOnError`]
///
/// * `onStreamChanged` - Monitor codec stream information, refer to [`OH_AVCodecOnStreamChanged`]
///
/// * `onNeedInputData` - Monitoring codec requires input data, refer to [`OH_AVCodecOnNeedInputData`]
///
/// * `onNeedOutputData` - Monitor codec to generate output data, refer to [`OH_AVCodecOnNewOutputData`]
///
/// **Deprecated** since 11
/// OH_AVCodecCallback
///
/// Available since API-level: 9
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AVCodecAsyncCallback {
    pub onError: OH_AVCodecOnError,
    pub onStreamChanged: OH_AVCodecOnStreamChanged,
    pub onNeedInputData: OH_AVCodecOnNeedInputData,
    pub onNeedOutputData: OH_AVCodecOnNewOutputData,
}
/// A collection of all asynchronous callback function pointers in OH_AVCodec. Register an instance of this
/// structure to the OH_AVCodec instance, and process the information reported through the callback to ensure the
/// normal operation of OH_AVCodec.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `onError` - Monitor OH_AVCodec operation errors, refer to [`OH_AVCodecOnError`]
///
/// * `onStreamChanged` - Monitor codec stream information, refer to [`OH_AVCodecOnStreamChanged`]
///
/// * `onNeedInputBuffer` - Monitoring codec requires input buffer, refer to [`OH_AVCodecOnNeedInputBuffer`]
///
/// * `onNewOutputBuffer` - Monitor codec to generate output buffer, refer to [`OH_AVCodecOnNewOutputBuffer`]
///
/// Available since API-level: 11
#[cfg(feature = "api-11")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AVCodecCallback {
    pub onError: OH_AVCodecOnError,
    pub onStreamChanged: OH_AVCodecOnStreamChanged,
    pub onNeedInputBuffer: OH_AVCodecOnNeedInputBuffer,
    pub onNewOutputBuffer: OH_AVCodecOnNewOutputBuffer,
}
/// the function pointer will be called to get sequence media data.
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
/// # Arguments
///
/// * `data` - OH_AVBuffer buffer to fill
///
/// * `length` - expected to read size;
///
/// * `pos` - current read offset
///
/// # Returns
///
/// * Actual size of data read to the buffer.
///
/// Available since API-level: 12
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
pub type OH_AVDataSourceReadAt = ::core::option::Option<
    unsafe extern "C" fn(data: *mut OH_AVBuffer, length: i32, pos: i64) -> i32,
>;
/// User customized data source.
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 12
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OH_AVDataSource {
    /// Total size of the data source.
    pub size: i64,
    /// Callback interface for reading data from datasource.
    pub readAt: OH_AVDataSourceReadAt,
}
impl OH_MediaType {
    pub const MEDIA_TYPE_AUD: OH_MediaType = OH_MediaType(0);
    pub const MEDIA_TYPE_VID: OH_MediaType = OH_MediaType(1);
    /// track is subtitle.
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub const MEDIA_TYPE_SUBTITLE: OH_MediaType = OH_MediaType(2);
}
#[repr(transparent)]
/// Media type.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 9
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_MediaType(pub ::core::ffi::c_uint);
impl OH_AACProfile {
    pub const AAC_PROFILE_LC: OH_AACProfile = OH_AACProfile(0);
    /// High-Efficiency AAC profile, contain the audio object types: AAC LC, SBR
    ///
    /// Available since API-level: 14
    #[cfg(feature = "api-14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-14")))]
    pub const AAC_PROFILE_HE: OH_AACProfile = OH_AACProfile(3);
    /// High-Efficiency AAC v2 profile, contain the audio object types: AAC LC, SBR, PS
    ///
    /// Available since API-level: 14
    #[cfg(feature = "api-14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-14")))]
    pub const AAC_PROFILE_HE_V2: OH_AACProfile = OH_AACProfile(4);
}
#[repr(transparent)]
/// AAC Profile
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 9
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_AACProfile(pub ::core::ffi::c_uint);
impl OH_AVCProfile {
    pub const AVC_PROFILE_BASELINE: OH_AVCProfile = OH_AVCProfile(0);
    pub const AVC_PROFILE_HIGH: OH_AVCProfile = OH_AVCProfile(4);
    pub const AVC_PROFILE_MAIN: OH_AVCProfile = OH_AVCProfile(8);
}
#[repr(transparent)]
/// AVC Profile
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 9
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_AVCProfile(pub ::core::ffi::c_uint);
impl OH_HEVCProfile {
    pub const HEVC_PROFILE_MAIN: OH_HEVCProfile = OH_HEVCProfile(0);
    pub const HEVC_PROFILE_MAIN_10: OH_HEVCProfile = OH_HEVCProfile(1);
    pub const HEVC_PROFILE_MAIN_STILL: OH_HEVCProfile = OH_HEVCProfile(2);
    ///
    /// **Deprecated** since 14
    #[deprecated(since = "14")]
    pub const HEVC_PROFILE_MAIN_10_HDR10: OH_HEVCProfile = OH_HEVCProfile(3);
    ///
    /// **Deprecated** since 14
    #[deprecated(since = "14")]
    pub const HEVC_PROFILE_MAIN_10_HDR10_PLUS: OH_HEVCProfile = OH_HEVCProfile(4);
}
#[repr(transparent)]
/// HEVC Profile
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_HEVCProfile(pub ::core::ffi::c_uint);
impl OH_AVOutputFormat {
    pub const AV_OUTPUT_FORMAT_DEFAULT: OH_AVOutputFormat = OH_AVOutputFormat(0);
    pub const AV_OUTPUT_FORMAT_MPEG_4: OH_AVOutputFormat = OH_AVOutputFormat(2);
    pub const AV_OUTPUT_FORMAT_M4A: OH_AVOutputFormat = OH_AVOutputFormat(6);
    /// The muxer output amr file format.
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub const AV_OUTPUT_FORMAT_AMR: OH_AVOutputFormat = OH_AVOutputFormat(8);
    /// The muxer output mp3 file format.
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub const AV_OUTPUT_FORMAT_MP3: OH_AVOutputFormat = OH_AVOutputFormat(9);
    /// The muxer output wav file format.
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub const AV_OUTPUT_FORMAT_WAV: OH_AVOutputFormat = OH_AVOutputFormat(10);
}
#[repr(transparent)]
/// Enumerates the muxer output file format
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_AVOutputFormat(pub ::core::ffi::c_uint);
impl OH_AVSeekMode {
    pub const SEEK_MODE_NEXT_SYNC: OH_AVSeekMode = OH_AVSeekMode(0);
    pub const SEEK_MODE_PREVIOUS_SYNC: OH_AVSeekMode = OH_AVSeekMode(1);
    pub const SEEK_MODE_CLOSEST_SYNC: OH_AVSeekMode = OH_AVSeekMode(2);
}
#[repr(transparent)]
/// Seek Mode
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_AVSeekMode(pub ::core::ffi::c_uint);
impl OH_ScalingMode {
    ///
    /// **Deprecated** since 14
    /// OH_SCALING_MODE_SCALE_TO_WINDOW_V2
    #[deprecated(since = "14")]
    pub const SCALING_MODE_SCALE_TO_WINDOW: OH_ScalingMode = OH_ScalingMode(1);
    ///
    /// **Deprecated** since 14
    /// OH_SCALING_MODE_SCALE_CROP_V2
    #[deprecated(since = "14")]
    pub const SCALING_MODE_SCALE_CROP: OH_ScalingMode = OH_ScalingMode(2);
}
#[repr(transparent)]
/// Scaling Mode
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// **Deprecated** since 14
/// OHScalingModeV2
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_ScalingMode(pub ::core::ffi::c_uint);
impl OH_BitsPerSample {
    pub const SAMPLE_U8: OH_BitsPerSample = OH_BitsPerSample(0);
    pub const SAMPLE_S16LE: OH_BitsPerSample = OH_BitsPerSample(1);
    pub const SAMPLE_S24LE: OH_BitsPerSample = OH_BitsPerSample(2);
    pub const SAMPLE_S32LE: OH_BitsPerSample = OH_BitsPerSample(3);
    pub const SAMPLE_F32LE: OH_BitsPerSample = OH_BitsPerSample(4);
    pub const SAMPLE_U8P: OH_BitsPerSample = OH_BitsPerSample(5);
    pub const SAMPLE_S16P: OH_BitsPerSample = OH_BitsPerSample(6);
    pub const SAMPLE_S24P: OH_BitsPerSample = OH_BitsPerSample(7);
    pub const SAMPLE_S32P: OH_BitsPerSample = OH_BitsPerSample(8);
    pub const SAMPLE_F32P: OH_BitsPerSample = OH_BitsPerSample(9);
    pub const INVALID_WIDTH: OH_BitsPerSample = OH_BitsPerSample(-1);
}
#[repr(transparent)]
/// enum Audio Bits Per Coded Sample
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_BitsPerSample(pub ::core::ffi::c_int);
impl OH_ColorPrimary {
    pub const COLOR_PRIMARY_BT709: OH_ColorPrimary = OH_ColorPrimary(1);
    pub const COLOR_PRIMARY_UNSPECIFIED: OH_ColorPrimary = OH_ColorPrimary(2);
    pub const COLOR_PRIMARY_BT470_M: OH_ColorPrimary = OH_ColorPrimary(4);
    pub const COLOR_PRIMARY_BT601_625: OH_ColorPrimary = OH_ColorPrimary(5);
    pub const COLOR_PRIMARY_BT601_525: OH_ColorPrimary = OH_ColorPrimary(6);
    pub const COLOR_PRIMARY_SMPTE_ST240: OH_ColorPrimary = OH_ColorPrimary(7);
    pub const COLOR_PRIMARY_GENERIC_FILM: OH_ColorPrimary = OH_ColorPrimary(8);
    pub const COLOR_PRIMARY_BT2020: OH_ColorPrimary = OH_ColorPrimary(9);
    pub const COLOR_PRIMARY_SMPTE_ST428: OH_ColorPrimary = OH_ColorPrimary(10);
    pub const COLOR_PRIMARY_P3DCI: OH_ColorPrimary = OH_ColorPrimary(11);
    pub const COLOR_PRIMARY_P3D65: OH_ColorPrimary = OH_ColorPrimary(12);
}
#[repr(transparent)]
/// Color Primary
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_ColorPrimary(pub ::core::ffi::c_uint);
impl OH_TransferCharacteristic {
    pub const TRANSFER_CHARACTERISTIC_BT709: OH_TransferCharacteristic =
        OH_TransferCharacteristic(1);
    pub const TRANSFER_CHARACTERISTIC_UNSPECIFIED: OH_TransferCharacteristic =
        OH_TransferCharacteristic(2);
    pub const TRANSFER_CHARACTERISTIC_GAMMA_2_2: OH_TransferCharacteristic =
        OH_TransferCharacteristic(4);
    pub const TRANSFER_CHARACTERISTIC_GAMMA_2_8: OH_TransferCharacteristic =
        OH_TransferCharacteristic(5);
    pub const TRANSFER_CHARACTERISTIC_BT601: OH_TransferCharacteristic =
        OH_TransferCharacteristic(6);
    pub const TRANSFER_CHARACTERISTIC_SMPTE_ST240: OH_TransferCharacteristic =
        OH_TransferCharacteristic(7);
    pub const TRANSFER_CHARACTERISTIC_LINEAR: OH_TransferCharacteristic =
        OH_TransferCharacteristic(8);
    pub const TRANSFER_CHARACTERISTIC_LOG: OH_TransferCharacteristic = OH_TransferCharacteristic(9);
    pub const TRANSFER_CHARACTERISTIC_LOG_SQRT: OH_TransferCharacteristic =
        OH_TransferCharacteristic(10);
    pub const TRANSFER_CHARACTERISTIC_IEC_61966_2_4: OH_TransferCharacteristic =
        OH_TransferCharacteristic(11);
    pub const TRANSFER_CHARACTERISTIC_BT1361: OH_TransferCharacteristic =
        OH_TransferCharacteristic(12);
    pub const TRANSFER_CHARACTERISTIC_IEC_61966_2_1: OH_TransferCharacteristic =
        OH_TransferCharacteristic(13);
    pub const TRANSFER_CHARACTERISTIC_BT2020_10BIT: OH_TransferCharacteristic =
        OH_TransferCharacteristic(14);
    pub const TRANSFER_CHARACTERISTIC_BT2020_12BIT: OH_TransferCharacteristic =
        OH_TransferCharacteristic(15);
    pub const TRANSFER_CHARACTERISTIC_PQ: OH_TransferCharacteristic = OH_TransferCharacteristic(16);
    pub const TRANSFER_CHARACTERISTIC_SMPTE_ST428: OH_TransferCharacteristic =
        OH_TransferCharacteristic(17);
    pub const TRANSFER_CHARACTERISTIC_HLG: OH_TransferCharacteristic =
        OH_TransferCharacteristic(18);
}
#[repr(transparent)]
/// Transfer Characteristic
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_TransferCharacteristic(pub ::core::ffi::c_uint);
impl OH_MatrixCoefficient {
    pub const MATRIX_COEFFICIENT_IDENTITY: OH_MatrixCoefficient = OH_MatrixCoefficient(0);
    pub const MATRIX_COEFFICIENT_BT709: OH_MatrixCoefficient = OH_MatrixCoefficient(1);
    pub const MATRIX_COEFFICIENT_UNSPECIFIED: OH_MatrixCoefficient = OH_MatrixCoefficient(2);
    pub const MATRIX_COEFFICIENT_FCC: OH_MatrixCoefficient = OH_MatrixCoefficient(4);
    pub const MATRIX_COEFFICIENT_BT601_625: OH_MatrixCoefficient = OH_MatrixCoefficient(5);
    pub const MATRIX_COEFFICIENT_BT601_525: OH_MatrixCoefficient = OH_MatrixCoefficient(6);
    pub const MATRIX_COEFFICIENT_SMPTE_ST240: OH_MatrixCoefficient = OH_MatrixCoefficient(7);
    pub const MATRIX_COEFFICIENT_YCGCO: OH_MatrixCoefficient = OH_MatrixCoefficient(8);
    pub const MATRIX_COEFFICIENT_BT2020_NCL: OH_MatrixCoefficient = OH_MatrixCoefficient(9);
    pub const MATRIX_COEFFICIENT_BT2020_CL: OH_MatrixCoefficient = OH_MatrixCoefficient(10);
    pub const MATRIX_COEFFICIENT_SMPTE_ST2085: OH_MatrixCoefficient = OH_MatrixCoefficient(11);
    pub const MATRIX_COEFFICIENT_CHROMATICITY_NCL: OH_MatrixCoefficient = OH_MatrixCoefficient(12);
    pub const MATRIX_COEFFICIENT_CHROMATICITY_CL: OH_MatrixCoefficient = OH_MatrixCoefficient(13);
    pub const MATRIX_COEFFICIENT_ICTCP: OH_MatrixCoefficient = OH_MatrixCoefficient(14);
}
#[repr(transparent)]
/// Matrix Coefficient
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_MatrixCoefficient(pub ::core::ffi::c_uint);
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
impl OH_AVCLevel {
    pub const AVC_LEVEL_1: OH_AVCLevel = OH_AVCLevel(0);
    pub const AVC_LEVEL_1b: OH_AVCLevel = OH_AVCLevel(1);
    pub const AVC_LEVEL_11: OH_AVCLevel = OH_AVCLevel(2);
    pub const AVC_LEVEL_12: OH_AVCLevel = OH_AVCLevel(3);
    pub const AVC_LEVEL_13: OH_AVCLevel = OH_AVCLevel(4);
    pub const AVC_LEVEL_2: OH_AVCLevel = OH_AVCLevel(5);
    pub const AVC_LEVEL_21: OH_AVCLevel = OH_AVCLevel(6);
    pub const AVC_LEVEL_22: OH_AVCLevel = OH_AVCLevel(7);
    pub const AVC_LEVEL_3: OH_AVCLevel = OH_AVCLevel(8);
    pub const AVC_LEVEL_31: OH_AVCLevel = OH_AVCLevel(9);
    pub const AVC_LEVEL_32: OH_AVCLevel = OH_AVCLevel(10);
    pub const AVC_LEVEL_4: OH_AVCLevel = OH_AVCLevel(11);
    pub const AVC_LEVEL_41: OH_AVCLevel = OH_AVCLevel(12);
    pub const AVC_LEVEL_42: OH_AVCLevel = OH_AVCLevel(13);
    pub const AVC_LEVEL_5: OH_AVCLevel = OH_AVCLevel(14);
    pub const AVC_LEVEL_51: OH_AVCLevel = OH_AVCLevel(15);
    pub const AVC_LEVEL_52: OH_AVCLevel = OH_AVCLevel(16);
    pub const AVC_LEVEL_6: OH_AVCLevel = OH_AVCLevel(17);
    pub const AVC_LEVEL_61: OH_AVCLevel = OH_AVCLevel(18);
    pub const AVC_LEVEL_62: OH_AVCLevel = OH_AVCLevel(19);
}
#[repr(transparent)]
/// AVC Level.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 12
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_AVCLevel(pub ::core::ffi::c_uint);
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
impl OH_HEVCLevel {
    pub const HEVC_LEVEL_1: OH_HEVCLevel = OH_HEVCLevel(0);
    pub const HEVC_LEVEL_2: OH_HEVCLevel = OH_HEVCLevel(1);
    pub const HEVC_LEVEL_21: OH_HEVCLevel = OH_HEVCLevel(2);
    pub const HEVC_LEVEL_3: OH_HEVCLevel = OH_HEVCLevel(3);
    pub const HEVC_LEVEL_31: OH_HEVCLevel = OH_HEVCLevel(4);
    pub const HEVC_LEVEL_4: OH_HEVCLevel = OH_HEVCLevel(5);
    pub const HEVC_LEVEL_41: OH_HEVCLevel = OH_HEVCLevel(6);
    pub const HEVC_LEVEL_5: OH_HEVCLevel = OH_HEVCLevel(7);
    pub const HEVC_LEVEL_51: OH_HEVCLevel = OH_HEVCLevel(8);
    pub const HEVC_LEVEL_52: OH_HEVCLevel = OH_HEVCLevel(9);
    pub const HEVC_LEVEL_6: OH_HEVCLevel = OH_HEVCLevel(10);
    pub const HEVC_LEVEL_61: OH_HEVCLevel = OH_HEVCLevel(11);
    pub const HEVC_LEVEL_62: OH_HEVCLevel = OH_HEVCLevel(12);
}
#[repr(transparent)]
/// HEVC Level.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 12
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_HEVCLevel(pub ::core::ffi::c_uint);
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
impl OH_TemporalGopReferenceMode {
    /// Refer to latest short-term reference frame.
    pub const ADJACENT_REFERENCE: OH_TemporalGopReferenceMode = OH_TemporalGopReferenceMode(0);
    /// Refer to latest long-term reference frame.
    pub const JUMP_REFERENCE: OH_TemporalGopReferenceMode = OH_TemporalGopReferenceMode(1);
    /// Uniformly scaled reference structure, which has even distribution of video frames after drop the highest
    /// enhance layer. The temporal group of pictures must be power of 2.
    pub const UNIFORMLY_SCALED_REFERENCE: OH_TemporalGopReferenceMode =
        OH_TemporalGopReferenceMode(2);
}
#[repr(transparent)]
/// The reference mode in temporal group of picture.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 12
#[cfg(feature = "api-12")]
#[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_TemporalGopReferenceMode(pub ::core::ffi::c_uint);
impl OH_BitrateMode {
    /// Constant Bit rate mode.
    pub const BITRATE_MODE_CBR: OH_BitrateMode = OH_BitrateMode(0);
    /// Variable Bit rate mode.
    pub const BITRATE_MODE_VBR: OH_BitrateMode = OH_BitrateMode(1);
    /// Constant Quality mode.
    pub const BITRATE_MODE_CQ: OH_BitrateMode = OH_BitrateMode(2);
}
#[repr(transparent)]
/// The bitrate mode of encoder.
///
/// Change the location of the header file, since 14.
///
///
/// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
///
/// Available since API-level: 10
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct OH_BitrateMode(pub ::core::ffi::c_uint);
extern "C" {
    /// Enumerates the mime types of video avc codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_AVCODEC_MIMETYPE_VIDEO_AVC: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio aac codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_AAC: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio flac codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_FLAC: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio vorbis codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_VORBIS: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio mp3 codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_MPEG: *const ::core::ffi::c_char;
    /// Enumerates the mime types of video hevc codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_VIDEO_HEVC: *const ::core::ffi::c_char;
    /// Enumerates the mime types of video mpeg4 muxer.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// **Deprecated** since 11
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_VIDEO_MPEG4: *const ::core::ffi::c_char;
    /// Enumerates the mime types of cover jpg muxer.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_IMAGE_JPG: *const ::core::ffi::c_char;
    /// Enumerates the mime types of cover png muxer.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_IMAGE_PNG: *const ::core::ffi::c_char;
    /// Enumerates the mime types of cover bmp muxer.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_AVCODEC_MIMETYPE_IMAGE_BMP: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio vivid codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_VIVID: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio amrnb codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_AMR_NB: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio amrwb codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_AMR_WB: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio opus codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_OPUS: *const ::core::ffi::c_char;
    /// Enumerates the mime types of audio g711mu codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_G711MU: *const ::core::ffi::c_char;
    /// Enumerates the mime type of audio ape codec.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_AVCODEC_MIMETYPE_AUDIO_APE: *const ::core::ffi::c_char;
    /// Enumerates the MIME type of versatile video coding.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_AVCODEC_MIMETYPE_VIDEO_VVC: *const ::core::ffi::c_char;
    /// Enumerates the mime type of subtitle srt.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_AVCODEC_MIMETYPE_SUBTITLE_SRT: *const ::core::ffi::c_char;
    /// Enumerates the mime type of subtitle webvtt.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_AVCODEC_MIMETYPE_SUBTITLE_WEBVTT: *const ::core::ffi::c_char;
    /// Key for timeStamp in surface's extraData, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// **Deprecated** since 14
    ///
    /// Available since API-level: 9
    pub static mut OH_ED_KEY_TIME_STAMP: *const ::core::ffi::c_char;
    /// Key for endOfStream in surface's extraData, value type is bool.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// **Deprecated** since 14
    ///
    /// Available since API-level: 9
    pub static mut OH_ED_KEY_EOS: *const ::core::ffi::c_char;
    /// Key for track type, value type is int32_t, see [`OH_MediaType`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_TRACK_TYPE: *const ::core::ffi::c_char;
    /// Key for codec mime type, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_CODEC_MIME: *const ::core::ffi::c_char;
    /// Key for file duration in microseconds, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_DURATION: *const ::core::ffi::c_char;
    /// Key for bitrate, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_BITRATE: *const ::core::ffi::c_char;
    /// Key for max input size, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_MAX_INPUT_SIZE: *const ::core::ffi::c_char;
    /// Key for video width, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_WIDTH: *const ::core::ffi::c_char;
    /// Key for video height, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_HEIGHT: *const ::core::ffi::c_char;
    /// Key for video pixel format, value type is int32_t, see [`OH_AVPixelFormat`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_PIXEL_FORMAT: *const ::core::ffi::c_char;
    /// key for audio raw format, value type is int32_t , see [`OH_BitsPerSample`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_AUDIO_SAMPLE_FORMAT: *const ::core::ffi::c_char;
    /// Key for video frame rate, value type is double.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_FRAME_RATE: *const ::core::ffi::c_char;
    /// video encode bitrate mode, the value type is int32_t, see [`OH_VideoEncodeBitrateMode`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_VIDEO_ENCODE_BITRATE_MODE: *const ::core::ffi::c_char;
    /// encode profile, the value type is int32_t. see [`OH_AVCProfile`], [`OH_HEVCProfile`],
    /// [`OH_AACProfile`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_PROFILE: *const ::core::ffi::c_char;
    /// Key for audio channel count, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_AUD_CHANNEL_COUNT: *const ::core::ffi::c_char;
    /// Key for audio sample rate, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_AUD_SAMPLE_RATE: *const ::core::ffi::c_char;
    /// Key for the interval of key frame. value type is int32_t, the unit is milliseconds. A negative value means no
    /// key frames are requested after the first frame. A zero value means a stream containing all key frames is requested.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_I_FRAME_INTERVAL: *const ::core::ffi::c_char;
    /// Key of the surface rotation angle. value type is int32_t: should be {0, 90, 180, 270}, default is 0.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 9
    pub static mut OH_MD_KEY_ROTATION: *const ::core::ffi::c_char;
    /// Key for video YUV value range flag, value type is bool, true for full range, false for limited range.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_RANGE_FLAG: *const ::core::ffi::c_char;
    /// Key for video color primaries, value type is int32_t, see [`OH_ColorPrimary`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_COLOR_PRIMARIES: *const ::core::ffi::c_char;
    /// Key for video transfer characteristics, value type is int32_t, see [`OH_TransferCharacteristic`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_TRANSFER_CHARACTERISTICS: *const ::core::ffi::c_char;
    /// Key for video matrix coefficients, value type is int32_t, see [`OH_MatrixCoefficient`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_MATRIX_COEFFICIENTS: *const ::core::ffi::c_char;
    /// Key for the request an I-Frame immediately, value type is bool.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_REQUEST_I_FRAME: *const ::core::ffi::c_char;
    /// Key for the desired encoding quality, value type is int32_t, this key is only.
    /// supported for encoders that are configured in constant quality mode.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_QUALITY: *const ::core::ffi::c_char;
    /// Key of the codec specific data. value type is a uint8_t pointer.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_CODEC_CONFIG: *const ::core::ffi::c_char;
    /// source format Key for title, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_TITLE: *const ::core::ffi::c_char;
    /// source format Key for artist, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_ARTIST: *const ::core::ffi::c_char;
    /// source format Key for album, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_ALBUM: *const ::core::ffi::c_char;
    /// source format Key for album artist, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_ALBUM_ARTIST: *const ::core::ffi::c_char;
    /// source format Key for date, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_DATE: *const ::core::ffi::c_char;
    /// source format Key for comment, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_COMMENT: *const ::core::ffi::c_char;
    /// source format Key for genre, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_GENRE: *const ::core::ffi::c_char;
    /// source format Key for copyright, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_COPYRIGHT: *const ::core::ffi::c_char;
    /// source format Key for language, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_LANGUAGE: *const ::core::ffi::c_char;
    /// source format Key for description, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_DESCRIPTION: *const ::core::ffi::c_char;
    /// source format Key for lyrics, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_LYRICS: *const ::core::ffi::c_char;
    /// source format Key for track count, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_TRACK_COUNT: *const ::core::ffi::c_char;
    /// Key for the desired encoding channel layout, value type is int64_t, this key is only supported for encoders.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_CHANNEL_LAYOUT: *const ::core::ffi::c_char;
    /// Key for bits per coded sample, value type is int32_t, supported for flac encoder,
    /// see [`OH_BitsPerSample`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_BITS_PER_CODED_SAMPLE: *const ::core::ffi::c_char;
    /// Key for the aac format, value type is int32_t, supported for aac decoder.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_AAC_IS_ADTS: *const ::core::ffi::c_char;
    /// Key for aac sbr mode, value type is int32_t, supported for aac encoder.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_SBR: *const ::core::ffi::c_char;
    /// Key for flac compliance level, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_COMPLIANCE_LEVEL: *const ::core::ffi::c_char;
    /// Key for vorbis identification header, value type is a uint8_t pointer, supported only for vorbis decoder.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_IDENTIFICATION_HEADER: *const ::core::ffi::c_char;
    /// Key for vorbis setup header, value type is a uint8_t pointer, supported only for vorbis decoder.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_SETUP_HEADER: *const ::core::ffi::c_char;
    /// Key for video scale type, value type is int32_t, see [`OH_ScalingMode`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// **Deprecated** since 14
    /// OH_NativeWindow_NativeWindowSetScalingModeV2
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_KEY_SCALING_MODE: *const ::core::ffi::c_char;
    /// Key for max input buffer count, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_MAX_INPUT_BUFFER_COUNT: *const ::core::ffi::c_char;
    /// Key for max output buffer count, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 10
    pub static mut OH_MD_MAX_OUTPUT_BUFFER_COUNT: *const ::core::ffi::c_char;
    /// Key for audio codec compression level, value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_MD_KEY_AUDIO_COMPRESSION_LEVEL: *const ::core::ffi::c_char;
    /// Key of the video is hdr vivid. value type is bool.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_MD_KEY_VIDEO_IS_HDR_VIVID: *const ::core::ffi::c_char;
    /// Key for number of audio objects. value type is int32_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_MD_KEY_AUDIO_OBJECT_NUMBER: *const ::core::ffi::c_char;
    /// Key for meta data of audio vivid. value type is a uint8_t pointer.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 11
    #[cfg(feature = "api-11")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-11")))]
    pub static mut OH_MD_KEY_AUDIO_VIVID_METADATA: *const ::core::ffi::c_char;
    /// Key for querying the maximum long-term reference count of video encoder, value type is int32_t.
    /// You should query the count through interface [`OH_AVCapability_GetFeatureProperties`]
    /// with enum [`VIDEO_ENCODER_LONG_TERM_REFERENCE`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_FEATURE_PROPERTY_KEY_VIDEO_ENCODER_MAX_LTR_FRAME_COUNT:
        *const ::core::ffi::c_char;
    /// Key for enable the temporal scalability mode, value type is int32_t (0 or 1): 1 is enabled, 0 otherwise.
    /// The default value is 0. To query supported, you should use the interface [`OH_AVCapability_IsFeatureSupported`]
    /// with enum [`VIDEO_ENCODER_TEMPORAL_SCALABILITY`]. This is an optional key that applies only to video encoder.
    /// It is used in configure.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_ENABLE_TEMPORAL_SCALABILITY: *const ::core::ffi::c_char;
    /// Key for describing the temporal group of picture size, value type is int32_t. It takes effect only when
    /// temporal level scale is enable. This is an optional key that applies only to video encoder. It is used in configure.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_TEMPORAL_GOP_SIZE: *const ::core::ffi::c_char;
    /// Key for describing the reference mode in temporal group of picture, value type is int32_t, see enum
    /// [`OH_TemporalGopReferenceMode`]. It takes effect only when temporal level sacle is enabled.
    /// This is an optional key that applies only to video encoder. It is used in configure.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_TEMPORAL_GOP_REFERENCE_MODE: *const ::core::ffi::c_char;
    /// Key for describing the count of used long-term reference frames, value type is int32_t, must be within the
    /// supported range. To get supported range, you should query wthether the capability is supported through the interface
    /// [`OH_AVCapability_GetFeatureProperties`] with enum [`VIDEO_ENCODER_LONG_TERM_REFERENCE`], otherwise, not set
    /// the key. This is an optional key that applies only to video encoder. It is used in configure.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_LTR_FRAME_COUNT: *const ::core::ffi::c_char;
    /// Key for describing mark this frame as a long term reference frame, value type is int32_t (0 or 1): 1 is mark,
    /// 0 otherwise. It takes effect only when the number of used long term reference frames is configured. This is an
    /// optional key that applies only to video encoder input loop. It takes effect immediately.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_MARK_LTR: *const ::core::ffi::c_char;
    /// Key for describing the long term reference frame poc referenced by this frame, value type is int32_t. This is
    /// an optional key that applies only to video encoder input loop. It takes effect immediately.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_PER_FRAME_USE_LTR: *const ::core::ffi::c_char;
    /// Key for indicating this frame is a long-term reference frame, value type is int32_t (0 or 1): 1 is LTR,
    /// 0 otherwise. This is an optional key that applies only to video encoder output loop.
    /// It indicates the attribute of the frame.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_PER_FRAME_IS_LTR: *const ::core::ffi::c_char;
    /// Key for describing the frame poc, value type is int32_t. This is an optional key that applies only to video
    /// encoder output loop. It indicates the attribute of the frame.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_PER_FRAME_POC: *const ::core::ffi::c_char;
    /// Key for describing the top-coordinate (y) of the crop rectangle, value type is int32_t. This is the top-most
    /// row included in the crop frame, where row indices start at 0.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_CROP_TOP: *const ::core::ffi::c_char;
    /// Key for describing the bottom-coordinate (y) of the crop rectangle, value type is int32_t. This is the
    /// bottom-most row included in the crop frame, where row indices start at 0.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_CROP_BOTTOM: *const ::core::ffi::c_char;
    /// Key for describing the left-coordinate (x) of the crop rectangle, value type is int32_t.
    /// This is the left-most column included in the crop frame, where column indices start at 0.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_CROP_LEFT: *const ::core::ffi::c_char;
    /// Key for describing the right-coordinate (x) of the crop rectangle, value type is int32_t. This is the
    /// right-most column included in the crop frame, where column indices start at 0.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_CROP_RIGHT: *const ::core::ffi::c_char;
    /// Key for describing the stride of the video buffer layout, value type is int32_t. Stride (or row increment) is
    /// the difference between the index of a pixel and that of the pixel directly underneath. For YUV 420 formats, the
    /// stride corresponds to the Y plane; the stride of the U and V planes can be calculated based on the color format,
    /// though it is generally undefined and depends on the device and release.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_STRIDE: *const ::core::ffi::c_char;
    /// Key for describing the plane height of a multi-planar (YUV) video buffer layout, value type is int32_t.
    /// Slice height (or plane height/vertical stride) is the number of rows that must be skipped to get from
    /// the top of the Y plane to the top of the U plane in the buffer. In essence the offset of the U plane
    /// is sliceHeight * stride. The height of the U/V planes can be calculated based on the color format,
    /// though it is generally undefined and depends on the device and release.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_SLICE_HEIGHT: *const ::core::ffi::c_char;
    /// Key for describing the valid picture width of the video, value type is int32_t.
    /// Get the value from an OH_AVFormat instance, which obtained by calling [`OH_VideoDecoder_GetOutputDescription`]
    /// or [`OH_AVCodecOnStreamChanged`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_PIC_WIDTH: *const ::core::ffi::c_char;
    /// Key for describing the valid picture height of the video, value type is int32_t.
    /// Get the value from an OH_AVFormat instance, which obtained by calling [`OH_VideoDecoder_GetOutputDescription`]
    /// or [`OH_AVCodecOnStreamChanged`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_PIC_HEIGHT: *const ::core::ffi::c_char;
    /// Key to enable the low latency mode, value type is int32_t (0 or 1):1 is enabled, 0 otherwise.
    /// If enabled, the video encoder or video decoder doesn't hold input and output data more than required by
    /// the codec standards. This is an optional key that applies only to video encoder or video decoder.
    /// It is used in configure.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENABLE_LOW_LATENCY: *const ::core::ffi::c_char;
    /// Key for describing the maximum quantization parameter allowed for video encoder, value type is int32_t.
    /// It is used in configure/setparameter or takes effect immediately with the frame.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_QP_MAX: *const ::core::ffi::c_char;
    /// Key for describing the minimum quantization parameter allowed for video encoder, value type is int32_t.
    /// It is used in configure/setparameter or takes effect immediately with the frame.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_QP_MIN: *const ::core::ffi::c_char;
    /// Key for describing the video frame averge quantization parameter, value type is int32_t.
    /// This is a part of a video encoder statistics export feature. This value is emitted from video encoder for a video
    /// frame.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_QP_AVERAGE: *const ::core::ffi::c_char;
    /// Key for describing video frame mean squared error, value type is double.
    /// This is a part of a video encoder statistics export feature. This value is emitted from video encoder for a video
    /// frame.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_ENCODER_MSE: *const ::core::ffi::c_char;
    /// Key for decoding timestamp of the buffer in microseconds, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_DECODING_TIMESTAMP: *const ::core::ffi::c_char;
    /// Key for duration of the buffer in microseconds, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_BUFFER_DURATION: *const ::core::ffi::c_char;
    /// Key for sample aspect ratio, value type is double.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_SAR: *const ::core::ffi::c_char;
    /// Key for start time of file, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_START_TIME: *const ::core::ffi::c_char;
    /// Key for start time of track, value type is int64_t.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_TRACK_START_TIME: *const ::core::ffi::c_char;
    /// Key for setting the output color space of video decoder. The value type is int32_t.
    /// The supported value is [`OH_COLORSPACE_BT709_LIMIT`], see [`OH_NativeBuffer_ColorSpace`]. It is used in
    /// [`OH_VideoDecoder_Configure`]. If the color space conversion capability is supported and this key is configured,
    /// the video decoder will automatically transcode an HDR Vivid video to an SDR video with color space BT709.
    /// If color space conversion capability is not supported, [`OH_VideoDecoder_Configure`] returns
    /// [`AV_ERR_VIDEO_UNSUPPORTED_COLOR_SPACE_CONVERSION`].
    /// If the input video is not an HDR vivid video, an error [`AV_ERR_VIDEO_UNSUPPORTED_COLOR_SPACE_CONVERSION`] will
    /// be reported by callback function [`OH_AVCodecOnError`].
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 12
    #[cfg(feature = "api-12")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-12")))]
    pub static mut OH_MD_KEY_VIDEO_DECODER_OUTPUT_COLOR_SPACE: *const ::core::ffi::c_char;
    /// Key for creation timestamp of a media file, value type is string.
    ///
    ///
    /// Required System Capabilities: SystemCapability.Multimedia.Media.CodecBase
    ///
    /// Available since API-level: 14
    #[cfg(feature = "api-14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "api-14")))]
    pub static mut OH_MD_KEY_CREATION_TIME: *const ::core::ffi::c_char;
}
